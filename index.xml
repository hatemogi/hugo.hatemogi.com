<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hatemogi&#39;s blog</title>
    <link>http://hatemogi.com/</link>
    <description>Recent content on hatemogi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 30 Apr 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://hatemogi.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2015 블로그 업데이트와 근황</title>
      <link>http://hatemogi.com/post/2015/0430-update/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/post/2015/0430-update/</guid>
      <description>

&lt;h3 id=&#34;hugo로-웹사이트-만들기:f123e9123c0e692add538cc883c04f28&#34;&gt;Hugo로 웹사이트 만들기&lt;/h3&gt;

&lt;p&gt;오랜만에 블로그를 정돈했습니다. 저는 개인 홈페이지를 &lt;strong&gt;정적 사이트 생성기 (static site generator)&lt;/strong&gt;를 사용해서 만드는데, 원래는 Ruby언어 기반의 &lt;a href=&#34;http://middlemanapp.com&#34;&gt;middleman&lt;/a&gt;을 써서 만들다가, 이번에 Go언어 기반의 &lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;로 바꿔서 만들어 봤습니다.&lt;/p&gt;

&lt;p&gt;어차피 제 개인 홈페이지는 방문자와의 동적인 연동이 필요 없어서, 별도로 웹서버를 만들어 띄울 필요가 없습니다. 혹시나 댓글을 달 수 있는 기능 정도를 넣을지도 모르겠지만, 그렇다 하더라도, &lt;a href=&#34;https://disqus.com&#34;&gt;Disqus&lt;/a&gt;등을 붙이면 프론트엔드에서 다 처리할 수 있어서, 번거롭게 웹서버를 따로 둘 필요가 없는 것이지요.&lt;/p&gt;

&lt;p&gt;쓰기 편한 &lt;strong&gt;정적 사이트 생성기&lt;/strong&gt;를 적당히 가져다가 Markdown으로 작성한 글들을 적당한 뼈대를 입혀 HTML파일로 다 만들고, 그렇게 만든 정적 파일들을 GitHub Pages나 S3에 올려서 사용자의 웹브라우저가 접근할 수 있도록 준비하면 그만입니다.&lt;/p&gt;

&lt;p&gt;Middleman이나 Hugo말고도 &lt;strong&gt;정적 사이트 생성기&lt;/strong&gt;는 매우 많습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://staticsitegenerators.net&#34;&gt;https://staticsitegenerators.net&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아마도, GitHub Pages에서 곧바로 지원하는 &lt;a href=&#34;http://jekyllrb.com&#34;&gt;Jekyll&lt;/a&gt;이 가장 널리 쓰이는 생성기일 것입니다.&lt;/p&gt;

&lt;p&gt;얼마전에 &lt;a href=&#34;http://golang.org&#34;&gt;Go 언어&lt;/a&gt;에 대한 관심이 높아져서, Go 언어에 대한 맛도 좀 더 볼 생각으로 개인 사이트를 Hugo로 만들어 봤습니다만, 한참 살펴보다보니, 정작 Go 언어에 대한 관심이 확 식어버렸습니다. 당분간 Hugo를 쓰다가, 결국 또다른 생성기로 바꾸게 될지도 모르겠네요.&lt;/p&gt;

&lt;h3 id=&#34;개인-근황:f123e9123c0e692add538cc883c04f28&#34;&gt;개인 근황&lt;/h3&gt;

&lt;p&gt;꽤 오래 근무하던 회사를 그만두었습니다. 다니던 회사는 그만 둘 때가 된 것 같고, 제주에는 계속 있고 싶어서 이런 저런 고민을 하던 찰나, 의미 있는 개발 프로젝트에 재택으로 근무할 수 있는 기회가 생겨서, 계속 제주에서 일하게 되었습니다.&lt;/p&gt;

&lt;p&gt;원격 재택 근무의 절차상, 여차저차하다보니 개인사업자 형태로 일하게 됐고, 얼떨결에 예상보다 빠르게 사업자가 됐습니다. 주계약 프로젝트는 Java로 개발하는 것이 위주라, 오랫동안 하지 않던 Java개발도 다시 하고 있습니다. 다행히도 Java 8을 쓸 수 있어서 lambda로 비교적 편하게 개발하고 있고, 비록 Scala가 아닌 Java로 쓰고 있지만, Play와 Akka도 쓰면서 그럭저럭 견뎌내고 있습니다. 써야하는 언어는 개인 성향과 맞지 않지만, 프로젝트 자체는 의미가 크기에 잘 해볼만 한 것 같습니다.&lt;/p&gt;

&lt;p&gt;메인 프로젝트와는 별개로, 개인적 성향을 만족시키기 위해, &lt;strong&gt;개인적으로 Clojure를 공부&lt;/strong&gt;하고 있습니다. Compojure를 써서 가볍게 웹서비스를 개발할 수 있다보니, Play로 덩치 크게 해야하는 이런 저런 욕구 불만을 다소나마 해결해가며 지내고 있습니다. 원래 즐겨쓰던 Ruby쪽 Sinatra의 느낌도 있고 좋습니다. 게다가 Lisp계열의 언어는 로망의 언어여서 좀 더 파고들어 보려합니다. 어차피 혼자 파고드는 것이니 제약 없이 이런 저런 언어와 프레임워크를 마구 써볼 수 있는 점을 만끽하고 있습니다. 어차피 혼자 개발하는 상황이라면, 주 언어를 Clojure나 Racket으로 가져가도 괜찮지 않을까 생각합니다.&lt;/p&gt;

&lt;p&gt;별다른 거 없이 이렇게 지내고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://hatemogi.com/about/</link>
      <pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/about/</guid>
      <description>&lt;div class=&#34;container-fluid&#34;&gt;
  &lt;div class=&#34;row&#34;&gt;
    &lt;div class=&#34;col-sm-3 col-xs-3&#34;&gt;
      &lt;img src=&#34;http://hatemogi.com/img/profile.jpg&#34;&gt;
      &lt;h4&gt;김대현&lt;/h4&gt;
      &lt;i class=&#34;fa fa-server&#34;&gt;&lt;/i&gt; 서버 프로그래머
    &lt;/div&gt;
    &lt;div class=&#34;col-sm-9&#34;&gt;
      &lt;p&gt;
        소프트웨어 개발자. 어려서 Apple IIe로 독학 프로그래밍에 빠져든 이래 개발을 취미이자 직업으로 삼았습니다. 홍익대에서 컴퓨터공학을 전공하고, 다음커뮤니케이션에서 클라우드기술팀 팀장을 거치며 만 10년 근무한 뒤, 지금은 프리랜서로 활동합니다.
      &lt;/p&gt;
      &lt;p&gt;
        Ruby나 Java로 서버사이드 개발을 해왔고, Angular.js를 다루는 프론트엔드 기술이나, iOS 애플리케이션을 만드는 일도 마다하지 않습니다. 최근에는 로망의 언어 Lisp 패밀리, 그중에서도 Clojure에 관심을 갖고 유심히 살피고 있습니다.
      &lt;/p&gt;
      &lt;p&gt;이 개인 사이트는 관심있는 기술 주제를 정리하는 공간으로 활용하려고 합니다. 아래의 소셜 사이트에서도 종종 활동합니다.&lt;/p&gt;

      &lt;ul class=&#34;list-unstyled&#34;&gt;
        &lt;li&gt;&lt;a href=&#34;https://github.com/hatemogi&#34;&gt;&lt;i class=&#34;fa fa-github&#34;&gt;&lt;/i&gt;  https://github.com/hatemogi&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;https://twitter.com/hatemogi&#34;&gt;&lt;i class=&#34;fa fa-twitter&#34;&gt;&lt;/i&gt; https://twitter.com/hatemogi&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;https://medium.com/@hatemogi&#34;&gt;&lt;i class=&#34;fa fa-medium&#34;&gt;&lt;/i&gt;  https://medium.com/@hatemogi&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;개인적 연락은 gmail의 제 아이디 앞으로 메일 주시면 답장드립니다. 감사합니다!&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>30일간의 웹개발 프로젝트</title>
      <link>http://hatemogi.com/project/30days/</link>
      <pubDate>Tue, 11 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/project/30days/</guid>
      <description></description>
    </item>
    
    <item>
      <title>애월입력기</title>
      <link>http://hatemogi.com/project/aewolinput/</link>
      <pubDate>Tue, 11 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/project/aewolinput/</guid>
      <description>&lt;p&gt;어쩌다 멀쩡히 잘 쓰던 기본 영문 자판을 두고 Dvorak이라는 생소한 자판 배열에 관심을 두게 됐을까요? 괜한 고생문을 연 것 같아서 이제라도 그냥 기본 키보드 배열을 다시 쓸까도 생각했지만, 직업이 프로그래머인지라 괜한 오기가 발동했습니다.&lt;/p&gt;

&lt;p&gt;같은 문제 상황에 처한 사람은 얼마 없겠지만, 그래도 나름 개발자인데 나만을 위해서라도 직접 문제를 해결해볼까?
해결하고자 한 문제가 무엇이었는지 말씀드리기 전에, 배경 설명이 필요합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/happyprogrammer-in-jeju/dvorak과-한글-입력기-개발-8940bc4714a1&#34;&gt;https://medium.com/happyprogrammer-in-jeju/dvorak과-한글-입력기-개발-8940bc4714a1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>팀장직 내려놓기</title>
      <link>http://hatemogi.com/post/2014/0713-no-more-managing/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/post/2014/0713-no-more-managing/</guid>
      <description>&lt;p&gt;2년 남짓 맡아왔던 개발팀장직을 내려놓았다. 연초부터 고민했던 일인데, 출산휴가와 안식휴가 2달을 틈타 고민도 더 하고, 결정도 미뤄왔던 일이다.&lt;/p&gt;

&lt;p&gt;주변에 보면 적지 않은 개발자가, 순수(?) 개발 일을 계속하고자 하지만, 결국 나이가 들면 안팍의 압력에 못 이기고, 매니저의 길로 들어서는 모습을 흔히 볼 수 있다. 나역시 어느정도 우리회사에서의 적정 나이(?)가 되어 팀장직을 맡게된 것이기도 했던 것같다.&lt;/p&gt;

&lt;p&gt;개발력이 뛰어난 팀원들과 함께 일할 수 있어 즐거운 시간이었고, 나름의 성과도 잘 드러났던 것 같아서 감사한 마음이 크다. 어느 순간이 되어 내가 아니더라도 우리 팀은 잘 지낼 수 있는 시기가 되었고, 나는 다시 개발자로 일하고자 내려오기로 했다.&lt;/p&gt;

&lt;p&gt;사실 팀장이 되기 전에는 팀장은 역할일 뿐, 위아래의 개념은 없다고 생각했는데, 사실상 겪어보니, 결국은 위아래의 환경이었다. 내가 위가 아니라고 생각해도, 팀원들은 나를 위라고 생각하고, 내가 조직도상 윗사람을 내 위가 아니라고 생각해도, 그 사람은 나를 아랫사람이라고 생각한다.&lt;/p&gt;

&lt;p&gt;하다보니 역할에 익숙해지기도 하고, 어떻게 하면 더 잘해볼 수 있을지 보이기도 했지만, 내가 잘하고 싶고, 즐겨하는 일은 개발이었지, 리딩이나 매니징이 아니라는 게 시간이 갈 수록 분명해졌다.&lt;/p&gt;

&lt;p&gt;어쨋건 운좋게(?) 다시 개발자로 조직도상 위치는 바뀌었지만, 아직 어떤 개발 일을 하게 될지는 미지수. 이제 이렇게 머리가 굵어져서, 그냥 아무 개발이나 할 수도 없고, 영락없이 꿔다 놓은 보릿자루 신세다.&lt;/p&gt;

&lt;p&gt;어떻게 자리 잡아갈지 두고 볼 일이다. 물론, 결국 자리를 못잡을 수도 있지만, 크게 걱정하지는 않는다. 어느정도 감안했던 일이다. 오히려, 반대로, 계속 매니저 트리를 탔다면, 그걸 더 걱정해야할 상황이었다.&lt;/p&gt;

&lt;p&gt;의외로, 이제야 조금 마음이 놓인다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 마지막날: 결과물 미리보기</title>
      <link>http://hatemogi.com/holiday-project-day-last/</link>
      <pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-last/</guid>
      <description>

&lt;p&gt;지금은 30여 일간의 휴가 마지막 날 밤이다. 한 달여 동안 알아보고 싶었던 주제들을 간략히나마 공부했고, 마지막 며칠 동안은 그 공부한 내용을 활용해보고자 간단한 웹서비스를 개발해 보고자 했다.&lt;/p&gt;

&lt;p&gt;처음의 목표 중 하나는 30일 동안 매일 블로그 글을 남기는 것도 있었는데, 마지막에 잘 지키지 못해서 아쉽지만, 그래도, 한가지 개발 주제도 잡았고, AngularJS나 D3같은 앞으로도 깊이 살펴볼 주제들을 찾게 돼서 좋았다.&lt;/p&gt;

&lt;h2 id=&#34;gvdoodle:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;gvDoodle&lt;/h2&gt;

&lt;p&gt;어떤 것을 개발할까 몇가지 머릿속으로만 고민하다가, 결국 주제로 잡은 것은&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;웹에서 &lt;a href=&#34;http://www.graphviz.org&#34;&gt;Graphviz&lt;/a&gt; 파일을 작성하고, 바로 확인해보고, 링크로 공유할 수 있는 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이다. &lt;a href=&#34;http://www.graphviz.org&#34;&gt;Graphviz&lt;/a&gt;를 온라인에서 실험해볼 수 있고, 생성한 .svg파일은 웹서비스로 제공해줘서,  외부의 다른 웹페이지 어디에서라도 HTML &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그로 걸어서 쓸 수 있다. &lt;a href=&#34;http://jsfiddle.net&#34;&gt;JSFiddle&lt;/a&gt;과 비슷한 개념의 웹서비스다.&lt;/p&gt;

&lt;p&gt;이름 하여, gv (graphviz)로 낙서(doodle)해본다는 의미로, gvdoodle!&lt;/p&gt;

&lt;h2 id=&#34;미리보기:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;미리보기&lt;/h2&gt;

&lt;p&gt;아직 너무 미흡해서, 제대로 소개하기도 모자란 단계다. 이 글을 작성하는 시점 기준, 아직 &lt;code&gt;Save&lt;/code&gt;도 안되고, 아무리 데스크톱 화면을 목표로 만들기는 했지만, 모바일에서 화면 깨지고 난리도 아님. 그래도, 아래 사이트에서 어떤 내용인지 미리 확인해 볼 수 있도록 준비했다. 왼쪽의 Example에서 .gv문서 예제 고르고, &lt;code&gt;Run&lt;/code&gt;버튼 실행해보면 즉석에서 결과 그래프를 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://preview.gvdoodle.com&#34;&gt;http://preview.gvdoodle.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;물론, 틈나는 대로 완성도를 높여나갈 예정이다.
오는 주말이 지나면, 다시 제대로 소개할 수 있기를 기대한다.&lt;/p&gt;

&lt;p&gt;소스코드는 아래 주소에 공개하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/gvdoodle&#34;&gt;https://github.com/hatemogi/gvdoodle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;휴가-끝:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;휴가 끝&lt;/h2&gt;

&lt;p&gt;매우 아쉽지만, 휴가는 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교</title>
      <link>http://hatemogi.com/holiday-project-day-22/</link>
      <pubDate>Sat, 31 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-22/</guid>
      <description>

&lt;p&gt;오늘은 프로젝트 22일째 작성한 Async.js 코드와 Promise 코드를 비교해본다.&lt;/p&gt;

&lt;h2 id=&#34;콜백-중첩의-늪:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;콜백 중첩의 늪&lt;/h2&gt;

&lt;p&gt;자바스크립트 자체만으로도 그렇지만, 특히 Node.js 환경은 비동기 I/O가 중요해서, 콜백 방식의 함수 호출이 자주 활용되며, 그 호출 간의 중첩도 잦다. 즉, 콜백에서 다시 콜백 걸고 또 콜백 거는, 계속 타고들어가는 콜백이 필요한 경우가 많다.&lt;/p&gt;

&lt;p&gt;이 연속되는 콜백을 그냥 평범하게 코딩하면, 마치 예외처리 (try-catch-finally) 구문 없이 코딩하는 것처럼, 예외 처리에 대한 코드가 중간중간 끼어들어서 정상적인 로직 코드가 묻혀버리기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-10/&#34;&gt;10일째 작성했던 코드를 다시 예로 들어보자.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)

describe &#39;[CoffeeScript] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    nodegit.Repo.open &amp;quot;git/nodegit&amp;quot;, (err, repo) -&amp;gt;
      return done(err) if err
      expect(repo.path()).toMatch /\.git\/$/
      repo.getCommit sha, (err, entry) -&amp;gt;
        return done(err) if err
        expect(entry.sha()).toEqual sha    
        done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보통의 비동기 콜백 함수들이 파라미터로 &lt;code&gt;(err, result)&lt;/code&gt;를 받는 형태이고, 처리 과정에서 에러가 발생하면 err에 에러 관련 값이 들어오고, 정상처리됐으면 null이 온다. 그리고, result에 결과값이 담겨있는 형태다.&lt;/p&gt;

&lt;p&gt;위 코드의 중간마다 있는 &lt;code&gt;return done(err) if err&lt;/code&gt; 부분이 에러 상황에 Jasmine 프레임워크에 에러 결과를 리포팅하겠다는 코드인데, 콜백 도입부마다 똑같은 코드를 넣어서 전체 코드가 눈에 잘 띄지 않게 됐다.&lt;/p&gt;

&lt;h2 id=&#34;promise와-async-js:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;Promise와 Async.js&lt;/h2&gt;

&lt;p&gt;이 불편함을 해결하는 방법이 여럿 있을 것 같은데, 그중에서도 Async.js와 Promise를 살펴봤다. Async.js는 비동기 호출에 편리한 유틸리티 함수들이 제공되는 라이브러리여서, npm등으로 잘 가져다가 사용하면 된다. 평범한 자바스크립트 라이브러리라 브라우저에서 사용해도 된다. 한편, Promise는 사실 자바스크립트(ECMAScript) 스펙에 포함되는 규약인데, 아직 지원하지 않는 자바스크립트 엔진을 위해, 별도 구현체 중에 하나 가져다가 쓰면 된다.&lt;/p&gt;

&lt;p&gt;콜백 방식의 호출은 물론, Promise와 Async.js도 익숙치 않기 때문에, 연습해볼 겸 똑같은 코드를 둘다의 방식으로 작성해봤다. nodegit으로 git 저장소를 열고, 커밋 두 개에 엮인 트리를 찾아서 둘 사이 차이(패치 크기)를 알아보는 메소드를 작성했고, 코드는 아래와 같다.&lt;/p&gt;

&lt;h3 id=&#34;async로-작성한-코드-https-github-com-hatemogi-holiday-project-blob-day-22-spec-nodegit-repo-async-spec-coffee:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_async_spec.coffee&#34;&gt;Async로 작성한 코드&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
async = require(&amp;quot;async&amp;quot;)
_ = require(&amp;quot;underscore&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

describe &#39;[CoffeeScript w/async.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    open = nodegit.Repo.open
    async.waterfall [
      open.bind(open, nodegitPath)
      (repo, cb) -&amp;gt;
        expect(repo.path()).toMatch /\/git\/nodegit\/$/
        repo.getCommit sha, cb
      (entry, cb) -&amp;gt;
        expect(entry.sha()).toEqual sha
        cb null
    ], done

  it &#39;diff 실행해보기&#39;, (done) -&amp;gt;
    async.waterfall [
      (cb) -&amp;gt;
        nodegit.Repo.open nodegitPath, cb
      (repo, cb) -&amp;gt;
        async.parallel [
          repo.getCommit.bind(repo, &amp;quot;33c7b930acc13148ef6f05df56f9b8a5c3578a57&amp;quot;),
          repo.getCommit.bind(repo, &amp;quot;c3e4be4448d2a99917431d3be972ca262805f989&amp;quot;)
        ], (err, commits) -&amp;gt; cb(err, repo, commits)
      (repo, commits, cb) -&amp;gt;
        async.parallel [
          repo.getTree.bind(repo, commits[0].treeId()),
          repo.getTree.bind(repo, commits[1].treeId())
        ], cb
      (trees, cb) -&amp;gt;
        trees[0].diff trees[1], cb
      (diff, cb) -&amp;gt;
        expect(_.reduce(diff.patches(), ((m, p) -&amp;gt; m + p.size()), 0)).toBe(2)
        cb null
    ], done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;async.waterfall&lt;/code&gt;과 &lt;code&gt;async.parallel&lt;/code&gt; 함수를 사용해서 작성했고, 전체적 흐름은 일관되고 편리하다. 하지만, 콜백 꼬리 &lt;code&gt;cb&lt;/code&gt;를 늘 달고 다녀야 하는 아쉬움(?)이 있다.&lt;/p&gt;

&lt;h3 id=&#34;promise로-작성한-코드-https-github-com-hatemogi-holiday-project-blob-day-22-spec-nodegit-repo-promise-spec-coffee:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_promise_spec.coffee&#34;&gt;Promise로 작성한 코드&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
Promise = require(&amp;quot;promise&amp;quot;)
_ = require(&amp;quot;underscore&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

openRepo = Promise.denodeify(nodegit.Repo.open)
getCommit = (repo) -&amp;gt;
  Promise.denodeify(repo.getCommit.bind(repo))
getTree = (repo) -&amp;gt;
  Promise.denodeify(repo.getTree.bind(repo))
getDiff = (tree) -&amp;gt;
  Promise.denodeify(tree.diff.bind(tree))

describe &#39;[CoffeeScript w/promise.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      expect(repo.path()).toMatch /\/git\/nodegit\/$/
      getCommit(repo)(sha)
    ).then((entry) -&amp;gt;
      expect(entry.sha()).toEqual sha
    ).then done, done

  it &#39;diff 실행해보기&#39;, (done) -&amp;gt;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      Promise.all([
        getCommit(repo)(&amp;quot;33c7b930acc13148ef6f05df56f9b8a5c3578a57&amp;quot;),
        getCommit(repo)(&amp;quot;c3e4be4448d2a99917431d3be972ca262805f989&amp;quot;)
      ]).then((c) -&amp;gt;
        Promise.all [
          getTree(repo)(c[0].treeId()),
          getTree(repo)(c[1].treeId())
        ]
      )
    ).then((trees) -&amp;gt;
      getDiff(trees[0])(trees[1])
    ).then((diff) -&amp;gt;
      patchsize = _.reduce(diff.patches(), ((m, p) -&amp;gt; m + p.size()), 0)
      expect(patchsize).toBe(2)
    ).then done, done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Promise의 경우, 전체 메시지를 마치 보통 동기 호출 스타일로 작성하자는 것이 포인트인데, 어떤 비동기 처리 뒤에 &lt;code&gt;then&lt;/code&gt; 함수를 붙여서, 성공한 경우와 실패한 경우의 처리를 한다. 계속 연결해서 (chaining) 사용하는 것이 핵심이라면 핵심이다.&lt;/p&gt;

&lt;p&gt;위 코드는 &lt;code&gt;Promise.then&lt;/code&gt;과 &lt;code&gt;Promise.all&lt;/code&gt;을 사용했다. 결국 두 코드 스타일이 비슷해졌다. 팀 동료들에게 물어보니, Async가 더 보기 좋다는 사람도 있던데, 내 경우에는 Promise가 좋게 느껴지는 면도 있다고 생각한다. 우선 늘 쫓아다녀야 하는 콜백 함수 꼬리표를 떼놓고 생각할 수 있고, 코드의 흐름이 차례로 흐르는 방식이 평소 동기화 방식 코딩을 할 때와 크게 다르지 않아서 좋다.&lt;/p&gt;

&lt;h2 id=&#34;그러나-둘-중-하나를-쓴다면:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;그러나, 둘 중 하나를 쓴다면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Async.js의 경우, 비동기 호출과 관련한 다양한 유틸리티가 많아서, 1:1로의 비교는 어렵지만, waterfall에 한정 지어 비교해본다면 결론이 쉽게 난다.&lt;/p&gt;

&lt;p&gt;Promise 스타일이 내게는 더 좋지만, 문제는, 이미 널리 있는 자바스크립트 라이브러리들이나 Node.js의 기본 API들이 일반 콜백 방식으로만 되어있지, Promise 스타일로 준비된 것이 아니어서, 위 코드에서처럼 &lt;code&gt;Promise.denodeify&lt;/code&gt;같은 유틸리티 함수로 Promise화 한다거나, 아니면 직접 Promise 함수로 만들어 놔야 한다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;한마디로, 이미 통용되는 코드를 그대로 활용하기에는 Async.js가 좋은 것 같다. Promise 스타일이 더 널리 쓰이기 시작해서 다른 API들도 그 스타일대로 쓸 수 있게 되면 적극적으로 활용해보기 좋다고 생각한다. 그전까지는 Async.js의 활용도가 더 높을 수밖에 없을 것 같다.&lt;/p&gt;

&lt;h2 id=&#34;한편-콜백의-불편함을-감수해야-하나:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;한편, 콜백의 불편함을 감수해야 하나?&lt;/h2&gt;

&lt;p&gt;한편, 조금 원론적인 얘기로, 비동기 코딩으로 왜 콜백의 불편함을 감수해야 할까? 자바스크립트 코딩할 때나, Node.js 코딩에서도 마찬가지로 그냥 동기화 방식으로 코딩하면 안 될까? 물론 된다. 하지만, 동기화 함수를 만날 때마다 블럭킹이 일어나면, 다른 코드가 동시에 실행될 수 없으므로, 클라이언트 코드의 경우 화면 응답성 등이 떨어질 것이고, 서버 코드의 경우 동시에 여러 사용자 처리를 할 수 없을 것이다.&lt;/p&gt;

&lt;p&gt;즉, 한마디로 동시성(concurrency) 확보를 위해 비동기 I/O 호출을 하게 되는 것인데, 사실 따지고 보면 기존에 JAVA 등으로 멀티쓰레딩 처리를 했던 것도 마찬가지로 동시성 확보를 위해 하는 일인데, 그 멀티 쓰레드 처리를 잘하기 위해 임계영역(critical section)을  잘 관리해야 하며, 신경 써야 할 점도 많다.&lt;/p&gt;

&lt;p&gt;어찌 보면 멀티쓰레드로 개발하는 것이, 당장엔 편해 보이지만 자칫하면 동시 사용자가 몰렸을 때 제대로 처리되지 않아 쓰레드 안정성(thread-safety)이 깨진 경우의 문제가 발생한다거나 하는 심각한 문제로의 발전 가능성이 있다. 그런 면에서는 콜백 처리의 불편함쯤이야 한번 감수하면 뒤탈은 적은 방식일지도 모른다.&lt;/p&gt;

&lt;p&gt;이상으로, Promise와 Async.js로 &lt;strong&gt;콜백 중첩 문제&lt;/strong&gt;를 해결해보았다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 21일: AngularJS 컨트롤러 테스트</title>
      <link>http://hatemogi.com/holiday-project-day-21/</link>
      <pubDate>Thu, 29 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-21/</guid>
      <description>

&lt;p&gt;이 글을 작성하는 지금은, 개인 프로젝트 23일째, 지난 21일째부터 정리하지 못한 밀린 숙제를 한다.&lt;/p&gt;

&lt;h2 id=&#34;숙제가-밀린-이유:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;숙제가 밀린 이유&lt;/h2&gt;

&lt;p&gt;21일째에는 AngularJS 코드를 테스트하려는 노력을 기울이다가, 블로그로 정리해야 할, 밤늦은 시간에 회사 동료들을 만나러 나갔다. 합병 소식에 허전해서였을까? 같은 단지에 사는 후배이자 동료를 불러봤는데, 마침 나올 수 있다고 했고, 그렇게 한 명 두 명 즉흥적으로 불러봤는데, 결국 5명이 모여서 늦은 시간까지 시끄럽게 떠들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/post/holiday-project/kcircle_hagun_jhban.jpg&#34; style=&#34;width: 400px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;한 명 더 왔었는데, 그가 왔을 때 이미 난 사진을 찍을 만한 상황이 아니었던지라, 이 사진이 전부다. 사진 잘 나왔다. 모두 다음의 탑클래스 개발자들이다. 치맥을 먹으면서도 &lt;code&gt;git stash&lt;/code&gt;와 Scala의 immutable 변수 &lt;code&gt;val&lt;/code&gt;을 논하는 천상 개발자들이다.&lt;/p&gt;

&lt;p&gt;아무튼 즐거운 시간을 보내고 집에 돌아왔는데, 만취 상태라서 프로젝트 기록을 남기기는커녕 다음 날까지도 숙취에 정신을 못 차리고, 이제야 뒤늦은 숙제를 다시 시작했다.&lt;/p&gt;

&lt;h2 id=&#34;angularjs-테스트-코드:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;AngularJS 테스트 코드&lt;/h2&gt;

&lt;p&gt;AngularJS 코드 스쿨 강의를 듣기 전에는 AngularJS는 조금 거창한 SPA (단일 페이지 웹 앱)에나 써볼 만한 거창한 프레임워크라고 생각했다. 강의를 듣고 나서야, SPA를 위해서도 좋지만, 멀티 페이지로 작성하더라도, 뷰와 로직을 잘 분리해 낼 수 있는 점과, 테스트를 잘할 수 있도록 준비돼 있다는 점이 훌륭하다는 것을 알게 됐다. 아예 템플릿 프로젝트 &lt;a href=&#34;https://github.com/angular/angular-seed&#34;&gt;angular-seed&lt;/a&gt;에 테스트 코드가 작성된 예제가 있다.&lt;/p&gt;

&lt;p&gt;그 예제 코드와 문서를 조금 살펴보고 나서 간단히나마 컨트롤러 테스트케이스를 작성할 수 있었다.&lt;/p&gt;

&lt;h3 id=&#34;angular-spec-js-https-github-com-hatemogi-holiday-project-blob-day-21-public-spec-angular-spec-js:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-21/public/spec/angular_spec.js&#34;&gt;angular_spec.js&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;angular 컨텍스트&#39;, function() {
  beforeEach(module(&amp;quot;holiday&amp;quot;));
  it(&amp;quot;버전 확인&amp;quot;, inject(function($controller) {
    expect(angular.version).toBeDefined();
    expect(angular.version.full).toEqual(&amp;quot;1.3.0-beta.8&amp;quot;);
    console.log($controller(&amp;quot;LoginCtrl&amp;quot;));
    expect($controller(&amp;quot;LoginCtrl&amp;quot;).welcome).toEqual(&amp;quot;환영합니다&amp;quot;);
  }));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적인 Jasmine 스펙 코드와 다른 점은 &lt;code&gt;beforeEach&lt;/code&gt;에 있는 &lt;code&gt;module&lt;/code&gt;이라는 함수와, &lt;code&gt;it&lt;/code&gt;에 걸려있는 &lt;code&gt;inject&lt;/code&gt;라는 함수다. 이 둘 다, &lt;a href=&#34;https://github.com/angular/bower-angular-mocks&#34;&gt;angular-mocks&lt;/a&gt; 모듈이 제공해주는 함수로, 테스트를 위해 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;module(모듈명)&lt;/code&gt; 함수는, 현재 Karma 환경에 로드된 AngularJS 앱을 기준으로 모듈을 찾아서 이하 테스트 케이스를 실행할 때 준비해준다. &lt;code&gt;inject&lt;/code&gt; 함수는 콜백에서 &lt;code&gt;$controller&lt;/code&gt; 파라미터를 받아서, 특정 컨트롤러를 받아올 수 있게 한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code&gt;$controller(&amp;quot;LoginCtrl&amp;quot;).welcome&lt;/code&gt;은, &lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-21/public/assets/app.js.coffee&#34;&gt;app.js.coffee&lt;/a&gt;에 선언한 컨트롤러의 welcome 속성을 읽는다.&lt;/p&gt;

&lt;p&gt;컨트롤러뿐 아니라, 필터나 디렉티브에 대한 테스트 케이스도 &lt;a href=&#34;https://github.com/angular/angular-seed/tree/master/test/unit&#34;&gt;angular-seed 프로젝트에서 예제&lt;/a&gt;를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;사실 테스트를 자동화한다는 것이 종종 생각만큼 쉽지 않고, 어떤 부분에서는 포기하게 되기 쉬운데, AngularJS가 이 정도로 친절하게 준비해주었으니, 그전보다는 공격적으로 더 많은 부분에서 테스트를 자동화해놓을 수 있겠다.&lt;/p&gt;

&lt;h2 id=&#34;promise와-async:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;Promise와 Async&lt;/h2&gt;

&lt;p&gt;AngularJS의 컨트롤러 스펙을 간단히 작성해보고 뿌듯한 마음으로, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-20/&#34;&gt;20일째 조금 알아본 Promise&lt;/a&gt;에 대해서도 더 알아보기 시작했다. &lt;a href=&#34;holiday-project-day-10/&#34;&gt;10일째 콜백 중첩을 풀기 위해 사용했던 Async.js&lt;/a&gt;와 비교해보고 싶었다. 어떨 때 어떻게 어느 것을 사용하면 좋을지 궁금했던 것인데, 둘 다 작성해보고 결국 마음에 드는 결론을 얻은 것은 프로젝트 22일째였다. 22일째 기록에 해당 내용을 정리하기로 한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 20일: 회사의 합병 소식</title>
      <link>http://hatemogi.com/holiday-project-day-20/</link>
      <pubDate>Mon, 26 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-20/</guid>
      <description>

&lt;p&gt;개인 프로젝트 20일째, 오늘은 내가 근무하는 회사가 다른 회사와 합병한다고 공시가 났다.&lt;/p&gt;

&lt;p&gt;겉으로야 합병이지만, 사실상 내용을 열어보면 우리가 인수당하는 입장이고, 앞으로 어떻게 될지는 알 수 없다. 당장 직속상관이 바뀌어도 업무가 확 바뀌는 것이 당연한데, 심지어 최대 주주가 바뀌는 일이니, 변화가 없을 수야 없겠지. 10년간 우리 회사가 다른 회사를 인수하거나 분사하는 것을 지켜봐 왔지만, 피인수는 처음이다. 나름 다채로운 근로자 생활이 되려나 보다.&lt;/p&gt;

&lt;p&gt;회사 분위기도 살피고, 사장님 발표도 들으러 잠시 출근했다. 출근한 김에, 팀원들에게 &lt;a href=&#34;http://hatemogi.com/holiday-project-day-19/&#34;&gt;어제 알아본 RequireJS&lt;/a&gt;와, Async와 Promise에 대해서도 물어봤다. 팀원들도 다행히 아직은 큰 동요가 없다, 아직 뭐 실감 날 일은 없으니까. 나도 아직은 멍하니 잘 모르겠고 말이다.&lt;/p&gt;

&lt;h2 id=&#34;amd-잘-쓰고-있나:d31268641f886a2ce4116b78b1519f75&#34;&gt;AMD 잘 쓰고 있나?&lt;/h2&gt;

&lt;p&gt;합병 관련해서야 내가 할 수 있는 일은 따로 없을 테고, 개인 프로젝트 얘기로 돌아오자.  이미 Node.js로 사내 서비스를 개발하고 있는 팀원들에게 물어보니, 아직 RequireJS같은 AMD를 쓰고 있지는 않았고, Promise 역시 스펙 정도만 보고, 실제로 써보지는 않은 단계였다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;minify 해서 다 로드해놓으면 되죠. JS 파일 다 합쳐봐야 얼마나 되나요? 그걸 굳이 나눠서 로드할 필요 있나요?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;맞는 말이다. 그래 봐야 텍스트 파일 아닌가? 신속한 네트워크 환경에서 텍스트 파일, 그것도 gzip으로 묶으면 이미지 파일 크기 정도인데, 그걸 어렵사리 lazy loading 하겠다고 노력하는 것도 지나친 수고일 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;promise는:d31268641f886a2ce4116b78b1519f75&#34;&gt;Promise는?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-10/&#34;&gt;10일차에 알아본 Async.js로 콜백 중첩을 푸는 방법&lt;/a&gt;에 대해서도 찜찜한 구석이 있어서, 다른 대안인 Promise에 대해서도 물어봤다. 한 명은 Promise는 오버엔지니어링인 것 같고, Async.js를 만족스럽게 쓰고 있다 했고, 한 명은, Promise를 써보지는 않고 스펙만 보았으나, 괜찮아 보인다고 했다.&lt;/p&gt;

&lt;p&gt;아직 모르는 입장에서는 남의 의견이 궁금하고, 또 중요하지만, 스스로 느끼기에도 async.waterfall도 아직 콜백 지옥을 완전히 해결해주지 못하는 것 같아서, Promise 관련해서도 조금 더 봤다. 스펙이 정리되고 있는 단계인데, 아직 지원하지 않는 JS엔진들이 더러 있어서, 그걸 메꿔주는 모듈들이 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://promisejs.org/&#34;&gt;http://promisejs.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffee&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
Promise = require(&amp;quot;promise&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

openRepo = Promise.denodeify(nodegit.Repo.open)

describe &#39;[CoffeeScript w/promise.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      expect(repo.path()).toMatch /\/git\/nodegit\/$/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nodegit.Repo&lt;/code&gt;의 &lt;code&gt;open&lt;/code&gt;이  일반 콜백 방식의 함수이고, 이걸 &lt;code&gt;Promise&lt;/code&gt; 식으로 바꿔서 호출하면, &lt;code&gt;then()&lt;/code&gt;에서 성공했을 경우의 결과 값으로 그다음 진행을 할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 한 단계의 콜백은 쉽게 &lt;code&gt;Promise.then()&lt;/code&gt; 으로 풀어쓰는 걸 알겠는데, waterfall을 해결하는 방법은 아직 와 닿지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://trevorburnham.com/presentations/flow-control-with-promises/&#34;&gt;http://trevorburnham.com/presentations/flow-control-with-promises/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기에 괜찮은 슬라이드 자료를 찾았다. 틈날 때 다시 공을 들여 읽어봐야겠다.&lt;/p&gt;

&lt;h2 id=&#34;coffeescript:d31268641f886a2ce4116b78b1519f75&#34;&gt;&lt;a href=&#34;http://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;또 한가지, 물어봤다. 커피스크립트는 어떻게 쓰고 있는지. 클라이언트 측 JS를 위해서야 컴파일도 미리 해놓고 최소화하는 것도 중요할 테니 미리미리 컴파일한다고 하더라도, 서버 측에서까지 매번 미리 컴파일하며, 각 커피 소스마다 JS파일 따로 만들어 놓는 게 여간 번거롭지 않았다. Ruby로 개발할 때야 신경 쓰지 않았다, 클라이언트 측 커피 코드만 컴파일했었으니까.&lt;/p&gt;

&lt;p&gt;어쨌건, 커피를 즐겨 쓰는 팀원 분의 의견은, 그냥 서버 실행을 &lt;code&gt;node&lt;/code&gt;가 아닌 &lt;code&gt;coffee&lt;/code&gt;로 한다는 것. 노드로 했을 경우에도, 한 줄의 설정으로 그다음 &lt;code&gt;require&lt;/code&gt;부터는 커피스크립트 소스를 그대로 읽을 수 있으니, 최초 진입 소스만 JS로 해도 되고, 아니면 최초 실행부터 아예 &lt;code&gt;coffee&lt;/code&gt;로 하면 최초 진입 소스와 그 후 require 모두 커피스크립트를 그대로 활용할 수 있다. 그래 그게 낫겠다. 서버 측이야, 떠 있는 애플리케이션이 계속 재활용되니까, 클라이언트 측처럼 매 클라이언트가 매번 컴파일 해야하는 것도 아니고 큰 부담 없겠다.&lt;/p&gt;

&lt;p&gt;지금까지 프로젝트 소스에는 커피스크립트와 JS를 혼용했는데, 오늘부로, 서버 측 코드는 커피스크립트로 통일했다. &lt;a href=&#34;http://js2coffee.org/&#34;&gt;js2coffee&lt;/a&gt;로 변환하고, 눈으로 직접보고 아주 약간씩만 손봤다.&lt;/p&gt;

&lt;p&gt;클라이언트 측 소스는 원래 하던 대로 커피스크립트 파일을 &lt;code&gt;asset&lt;/code&gt; 디렉터리에 두고, 그때그때 JS 파일로 변환하는 방식을 유지하기로 한다.&lt;/p&gt;

&lt;h2 id=&#34;프로젝트는-지지부진:d31268641f886a2ce4116b78b1519f75&#34;&gt;프로젝트는 지지부진&lt;/h2&gt;

&lt;p&gt;오늘의 성과는, 커피스크립트로 통일 전환한 것이 전부다. Promise라도 조금 더 이해할 수 있었으면 정리할 내용이 있었을 것 같은데 아쉽다. 합병 소식에 어수선했다고 얘기하면 핑계겠지.&lt;/p&gt;

&lt;p&gt;아! 그래서 결국 AMD를 쓰는 것에 대한 오늘의 방안은, D3.js를 비롯한 대부분은 AMD 방식으로 로딩하고, AngularJS만 일반 동기식으로 로딩하자는 것이다. AngularJS도 익숙하지 않고, AMD방식의 RequireJS도 익숙치 않아서, 어딘가 문제가 발생하면, 두 부분 중 어디서 잘못했는지 파악하기가 어렵다. 따라서 Angular만이라도 일반적(!)으로 로딩해서, 우선 문제 범위를 줄여놓고 진행하다가, 익숙해지면, 다시 비동기 로딩으로 전환하는 방법을 택하겠다.&lt;/p&gt;

&lt;p&gt;어떤 개발이든 마찬가지다. 무언가를 변경하거나 새로 할 때는, 불투명한 범위를 최소화해놓고, 부분과 단계별로 &lt;a href=&#34;https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms&#34;&gt;Divide &amp;amp; Conquer&lt;/a&gt;하는 것이 기본이다.&lt;/p&gt;

&lt;p&gt;다행히, 오늘 작업 중에야 RequireJS가 조금 파악이 되어, 조만간 AnguarJS도 비동기 로딩할 수 있을 것 같은 기대가 든다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 19일: RequireJS - 비동기(async) JS 로더</title>
      <link>http://hatemogi.com/holiday-project-day-19/</link>
      <pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-19/</guid>
      <description>

&lt;p&gt;개인 프로젝트 19일째, 오늘은 비동기식 자바스크립트 로더, &lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;에 대해 살펴봤다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/requirejs-logo.png&#34; style=&#34;width: 200px;&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;비동기-모듈-선언-amd:76bc47f87822f82bbf96592482914fb5&#34;&gt;비동기 모듈 선언 (AMD)&lt;/h2&gt;

&lt;p&gt;오늘 고생된 작업의 시작은, 오전에 지금까지 진행한 프로젝트 데모 사이트에서, 크롬 브라우저의 &lt;a href=&#34;https://chrome.google.com/webstore/detail/pagespeed-insights-by-goo/gplegfbjlmmehdoakndmohflojccocli?hl=ko&#34;&gt;PageSpeed&lt;/a&gt;를 돌려본 것이 화근이었다.  웹페이지 로딩 속도에 관련한 각종 검사를 하고 개선할 방안을 추천해주는 &lt;a href=&#34;https://chrome.google.com/webstore/detail/pagespeed-insights-by-goo/gplegfbjlmmehdoakndmohflojccocli?hl=ko&#34;&gt;PageSpeed&lt;/a&gt;가 내게 권장하기를,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;자바스크립트 파일들을 비동기식으로 로딩하시죠~!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라고 하는 게 아닌가?!&lt;/p&gt;

&lt;p&gt;음, 비동기식 로딩이라&amp;hellip; &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그의 가장 마지막에 자바스크립트 파일들을 로딩하면 되는건가? 아니면, &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에 &lt;code&gt;async&lt;/code&gt; 속성을 주면 되는 건가?&lt;/p&gt;

&lt;p&gt;조금 찾아보니, &lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;AMD&lt;/a&gt;라고 비동기 모듈 선언(Asynchronous Module Definition)이라는 주제를 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/AMD_overview.png&#34; alt=&#34;https://en.wikipedia.org/wiki/File:Asynchronous_Module_Definition_overview.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;쉽게 말해서, 여러 JS 파일들을 하나씩 차례로 읽지 말고, 동시다발적으로 읽자는 얘기고, 그러면 당연히 여러 파일을 전부 다 읽는 데 필요한 시간이 줄어들 수 있다는 얘기다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://requirejs.org/docs/whyamd.html&#34;&gt;이걸 왜 써야 하는지 아주 상세한 문서&lt;/a&gt;가 있는데, 상세한 만큼, 내용도 길다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;그냥 HTML 문서에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 넣으면 되는 것을, 이 장문의 영문을 읽고 해석하고 적용해야 하는 걸까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하는 불평이 스멀스멀 올라왔지만, &amp;ldquo;그래 어디 한번 써보기나 합시다&amp;rdquo;는 마음으로 적용해보기로 했다. AMD를 위한 라이브러리가 꽤 여럿 있는 것 같은데, 그중에서도 가장 눈에 띈 &lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;를 써보기로 했다.&lt;/p&gt;

&lt;p&gt;일단 아주 긴 문서 길이에 살짝 위축됐고, AngularJS나 Karma와의 궁합이 잘 안 맞을 수 있으니, 자칫하면 취소하려는 마음으로 브랜치부터 땄다. 지금까지의 &lt;code&gt;master&lt;/code&gt; 브랜치에서 &lt;code&gt;require.js&lt;/code&gt; 브랜치를 땄다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout -b require.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;requirejs-적용-시도:76bc47f87822f82bbf96592482914fb5&#34;&gt;RequireJS 적용 시도&lt;/h2&gt;

&lt;p&gt;문서를 보며 따라 해보니, 기본 개념은 아래 코드가 핵심이었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;모듈ID&#39;, [&#39;필요한모듈1&#39;, &#39;필요한모듈2&#39;], function(모듈1, 모듈2) {
  // 모듈1, 모듈2를 사용해서 무언가를 하는 코드
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특정 모듈을 &lt;code&gt;define&lt;/code&gt; 이라는 함수로 선언한 수 있고, 그 모듈은 &lt;code&gt;필요한모듈1&lt;/code&gt;과 &lt;code&gt;필요한모듈2&lt;/code&gt;를 필요로 하는 상황이다. 이 모듈을 쓰고자 한다면, RequireJS가 그 모듈들을 로드한 뒤에 이 모듈 선언 함수 부분을 실행한다. 즉, 의존성을 쫓아 로드할 수 있다.&lt;/p&gt;

&lt;p&gt;비동기로 동시다발적으로 로드하고, 의존성이 있는 경우에는, 그 의존하는 모듈이 로드된 다음에 해당 코드를 실행할 수 있으므로, 로드 순서에 따른 문제도 피할 수 있고, 전체 로딩 시간은 짧아지는 효과를 노리는 것이다.&lt;/p&gt;

&lt;p&gt;게다가, 선언만 해놓고, 실제로 쓰지 않는다면, 불필요하게 읽지 않으므로, 웹사이트의 전반적인 속도가 빠르게 느껴질 수도 있다. 예를 들어, 웹사이트 일부에 &lt;code&gt;D3.js&lt;/code&gt;를 쓰는 경우, 의존성 선언을 해놓고, 필요한 부분에서만 디펜던시를 걸어서 사용하면, 꼭 필요한 경우에만 로딩되게 할 수 있다.&lt;/p&gt;

&lt;p&gt;개념이며 목표며, 다 좋은데, 실제로 적용해보려니, Karma와 같이 쓰기가 쉽지 않았다. &lt;a href=&#34;http://karma-runner.github.io/0.8/plus/RequireJS.html&#34;&gt;Karma 사이트에 RequireJS와 함께 쓰는 법을 알려주는 문서&lt;/a&gt;가 있었지만, 아직 이해가 부족해서인지 따라해 봐도 쉽게 해결할 수 없었다.&lt;/p&gt;

&lt;p&gt;한나절 전부를 써서, 결국 간단히 Karma로도 테스트를 수행하고, 웹 브라우저에서도 잘 동작하는 코드를 작성할 수 있었는데, 그래도 아직 뭔가 부족하다. 아직 AngularJS의 컨트롤러 등을 테스트하는 코드를 깔끔하게 작성하지 못한 상태다.&lt;/p&gt;

&lt;p&gt;AngularJS는 별도 의존성이 없으므로,  차라리 그냥 동기 방식으로 미리 로딩하고, 나머지만 RequireJS에 묶는 게 편할지도 모르겠다. 계속 써볼지 말지 아직은 불투명한 상황. 내일이라도 지금 작업하는 브랜치를 그냥 지워버릴지도&amp;hellip; ㅠ.ㅠ&lt;/p&gt;

&lt;p&gt;우선, RequireJS를 적용한 브랜치는 아래 주소에 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/tree/require.js&#34;&gt;https://github.com/hatemogi/holiday-project/tree/require.js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-18&#34;&gt;어제&lt;/a&gt; 알아본 Grunt로 &lt;code&gt;karma&lt;/code&gt; 태스크를 넣어두었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt karma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간신히, 기본적으로 돌아가게는 했으나, 아직 더 자세히 알아보며 써봐야 할 단계다. 이해가 부족하다.&lt;/p&gt;

&lt;h2 id=&#34;새로운-웹-개발-기술들:76bc47f87822f82bbf96592482914fb5&#34;&gt;새로운 웹 개발 기술들&lt;/h2&gt;

&lt;p&gt;무엇 하나 개발하기에도 바쁜 데, 늘 따라가기 힘든 새로운 기술들이 쏟아져 나온다. 하도 많이 나와서, 다 알아보기도 힘들고, 또 대다수는 조금 쓰이다가, 버려지는 것들도 있어서 남들이 많이 쓰기 전까지는 기다리는 것이 현명한 판단일 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만, 그렇다고 늘 하던 대로만 하면, 나아지는 것이 없다.&lt;/p&gt;

&lt;p&gt;나름의 내 정체성은 (아직) 웹 개발자인데, 너무 모르고 지나가는 기술들이 많았었나 보다. 모르는 기술들을 뒤늦게 살펴보고 있으니,  정작 &lt;strong&gt;실제&lt;/strong&gt; 개발작업은 더뎌져서 답답하기도 한데, 그래도 당장 현업의 개발 업무가 눈앞에 있다면, 이렇게 모르는 기술 알아볼 시간도 없이 개발했을텐데, 이번 기회에 여유롭게(?) 이것저것 다양히 알아보고 있으니, 그것참 사치스러운 시간이다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 18일: Grunt - 자바스크립트 작업 실행기</title>
      <link>http://hatemogi.com/holiday-project-day-18/</link>
      <pubDate>Sat, 24 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-18/</guid>
      <description>

&lt;p&gt;개인 프로젝트 18일째, 오늘은 자바스크립트 작업 실행기(task runner), &lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;를 프로젝트에 적용했다. 자동화 테스트를 실행하거나, 자바스크립트 파일들을 합치거나 최소화하는 일처럼 자주 반복하는 프로젝트 수반 작업을 편리하게 실행할 수 있게 해주는 도구다.&lt;/p&gt;

&lt;p&gt;Node 환경에서는, npm만으로도 충분할 수 있는데, &lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;에 몇 가지 마음에 드는 &lt;a href=&#34;https://github.com/gruntjs&#34;&gt;플러그인&lt;/a&gt;이 있어서, 곧바로 적용해 보기로 했다.&lt;/p&gt;

&lt;p&gt;우선 npm으로 간단히 Grunt를 설치한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gruntfile-기본:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Gruntfile 기본&lt;/h2&gt;

&lt;p&gt;Make를 쓸 때 Makefile이나 Rake를 쓸 때 Rakefile이 있듯, Grunt를 위해서는 &lt;code&gt;Gruntfile.js&lt;/code&gt;가 있다. 프로젝트 디렉터리에 있는 이 파일을 기준으로 각종 작업을 실행한다.&lt;/p&gt;

&lt;h3 id=&#34;gruntfile-js-예제:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Gruntfile.js 예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = function(grunt) {
  // 작업을 위한 설정
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
      build: {
        src: &#39;src/app.js&#39;,
        dest: &#39;build/app.min.js&#39;
      }
    }
  });

  // &amp;quot;uglify&amp;quot; 작업을 위한 플러그인 등록
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);

  // 기본 작업에 &#39;uglify&#39; 등록
  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 &lt;code&gt;Gruntfile.js&lt;/code&gt;를 프로젝트 최상위 디렉터리에 두고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 명령을 실행하면, 아무 작업 이름을 주지 않았으므로 &lt;code&gt;default&lt;/code&gt; 작업을 실행하려고 하며, 위 &lt;code&gt;Gruntfile.js&lt;/code&gt;의 최하단에 명시한 대로 &lt;code&gt;uglify&lt;/code&gt; 작업을 진행한다. 그러면, &lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-uglify&#34;&gt;uglify 플러그인&lt;/a&gt;로 등록한 작업을 한다.&lt;/p&gt;

&lt;p&gt;즉, 위 예제의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt uglify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;라고 실행해도 결과는 같다. 참고로 &lt;code&gt;Gruntfile.js&lt;/code&gt; 대신 &lt;code&gt;Gruntfile.coffee&lt;/code&gt; 파일을 준비해 둬도 그 역할은 같으며, 단지 자바스크립트 대신 커피스크립트 문법으로 해석한다.&lt;/p&gt;

&lt;h2 id=&#34;grunt-플러그인-추가:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Grunt 플러그인 추가&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gruntjs&#34;&gt;플러그인&lt;/a&gt;이 꽤 많았고, 그중 아래의 플러그인을 골라 설치했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-coffee&#34;&gt;grunt-contrib-coffee&lt;/a&gt;: 커피스크립트 컴파일&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-uglify&#34;&gt;grunt-contrib-uglify&lt;/a&gt;: Ugilfy로 자바스크립트 파일 최소화&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-watch&#34;&gt;grunt-contrib-watch&lt;/a&gt;: 특정 파일들 감시하다가, 변경되면 지정한 작업 수행&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-jshint&#34;&gt;grunt-contrib-jshint&lt;/a&gt;: JSHint로 자바스크립트 파일 검증&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이하는, 오늘 작성한 &lt;code&gt;Gruntfile.coffee&lt;/code&gt; 파일의 일부다.&lt;/p&gt;

&lt;h3 id=&#34;gruntfile-coffee-https-github-com-hatemogi-holiday-project-blob-day-18-gruntfile-coffee:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-18/Gruntfile.coffee&#34;&gt;Gruntfile.coffee&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports = (grunt) -&amp;gt;
  js_files = [&#39;app.js&#39;, &#39;lib/*.js&#39;, &#39;public/js/app.js&#39;]

  grunt.initConfig {
    # 중간 생략
    watch:  {
      coffee: {
        files: [&amp;quot;public/assets/*.coffee&amp;quot;]
        tasks: [&amp;quot;coffee&amp;quot;, &amp;quot;uglify&amp;quot;]
      }
      jshint: {
        files: js_files
        tasks: [&amp;quot;jshint&amp;quot;]
      }
    }

    jshint: {
      all: js_files
    }
  }
  # 중간 생략
  grunt.registerTask &#39;default&#39;, [&#39;coffee&#39;, &#39;uglify&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본 작업에는 &lt;code&gt;coffee&lt;/code&gt;와 &lt;code&gt;uglify&lt;/code&gt;를 걸어 두었고, 별도로 &lt;code&gt;watch&lt;/code&gt; 작업을 추가해서,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;를 실행해 두고, 커피스크립트 소스파일을 편집하면, 그 후 저장할 때마다, 즉시 커피스크립트 컴파일하며, jshint로도 바로 검사한다. 더 나아가, 셀프 테스팅 코드도 &lt;code&gt;watch&lt;/code&gt;에 걸어두면, 그때그때 테스트 결과도 바로 확인할 수 있겠다.&lt;/p&gt;

&lt;h2 id=&#34;grunt-쓸만한가:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Grunt, 쓸만한가?&lt;/h2&gt;

&lt;p&gt;npm의 script 섹션을 써도 웬만큼 다 되는데, 굳이 수고를 들여 별도의 작업 실행기가 필요할까? 잠깐 살펴보니, 그래도 될 거 같다. 우선 그 약간의 수고가 크지 않게 잘 만들어져있고, 문서화도 잘 돼 있다. 무엇보다, 플러그인이 많아서, 원하는 기능을 손쉽게 가져다 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;그리고, 참고로, &lt;a href=&#34;http://gruntjs-kr.herokuapp.com/&#34;&gt;Grunt (비공식) 한글 사이트&lt;/a&gt;도 있으니, 한글 문서로도 살펴볼 수 있어서 좋다.&lt;/p&gt;

&lt;p&gt;오늘 작업을 포함해, 지금까지 진행하고 있는 내용을 GitHub에 올려놓고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project&#34;&gt;https://github.com/hatemogi/holiday-project&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;진행하는 내용은, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-17/&#34;&gt;어제 살펴본 Travis CI&lt;/a&gt;로 지속적으로 통합되며, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-14/&#34;&gt;Heroku&lt;/a&gt;에 이하 주소로 자동 스테이징되고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://holiday-project-staging.herokuapp.com&#34;&gt;https://holiday-project-staging.herokuapp.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 17일: Travis CI, 지속적 통합 서비스</title>
      <link>http://hatemogi.com/holiday-project-day-17/</link>
      <pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-17/</guid>
      <description>

&lt;p&gt;개인 프로젝트 17일째, 오늘은 지속적 통합 서비스인 &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;를 살펴보고, 개인 프로젝트에 적용해봤다.&lt;/p&gt;

&lt;h2 id=&#34;travis-ci-소개:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Travis CI 소개&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;는 GitHub과 연동해 &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;지속적 통합(Continuous Integration)&lt;/a&gt;을 호스팅해주는 서비스다.&lt;/p&gt;

&lt;p&gt;지속적 통합의 정확한 의미는 조금 더 넓을 수 있지만, &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;로 한정해서 쉽게 생각하자면, GitHub 저장소에 새로운 커밋이 push되었을 때 CI 서버가 뒤에서 자동으로 새로운 커밋을 가져와서 빌드 테스트를 수행하고, 그 결과를 리포팅 해주는 서비스다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C, C++, Clojure, Erlang, Go, Groovy, Haskell, Java, JavaScript (Node.js), Objective-C, Perl, PHP, Python, Ruby, Scala&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이상의 다양한 언어 환경에서의 빌드 테스트를 대행해주고, 더불어 다양한 데이터스토어와 메시지 브로커 같은 툴들도 미리 설치돼 있어서, 테스트를 위해 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 언어도 비슷하겠지만, Node.js의 경우에도 버전을 명시해서 여러 버전에 대해 동시에 테스트를 맡길 수도 있다. 예를 들어, 0.10.x 버전과 0.8.x 버전 모두에서 테스트하고 결과를 확인하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt; 사이트에 GitHub 계정으로 로그인할 수 있고, 연동된 기능을 통해 로그인한 계정의 저장소 목록을 열람하고, 웹 훅(Web Hook)을 간단히 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;웹 훅이 설정되고 나서 GitHub 저장소에 새로운 커밋이 들어오면, &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;가 바로 알게 되고, 설정에 따라 빌드 테스트를 수행한다. 설정을 위해서는 저장소에 &lt;code&gt;.travis.yml&lt;/code&gt;이라는 YAML 파일을 넣어 두면 된다. Node.js용 설정 파일의 예는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt; language: node_js
 node_js:
   - &amp;quot;0.10&amp;quot;
   - &amp;quot;0.11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 설정한 프로젝트의 경우, 0.10.x대의 최신 버전과, 0.11.x대의 최신 버전으로 빌드 테스트를 진행한다.&lt;/p&gt;

&lt;h2 id=&#34;travis-ci-적용:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Travis CI 적용&lt;/h2&gt;

&lt;p&gt;현재 진행하는 프로젝트의 &lt;a href=&#34;https://github.com/hatemogi/holiday-project/&#34;&gt;GitHub 저장소&lt;/a&gt;에 Travis CI를 적용했다.&lt;/p&gt;

&lt;h3 id=&#34;프로젝트-현재-상태-https-travis-ci-org-hatemogi-holiday-project-builds-25843181:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://travis-ci.org/hatemogi/holiday-project/builds/25843181&#34;&gt;프로젝트 현재 상태&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-current-status.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;간단히 적절한 설정을 한 뒤, 저장소에 &lt;code&gt;git push&lt;/code&gt;를 하고 나면, Travis CI가 테스트를 수행하고, 위와 같은 &lt;a href=&#34;https://travis-ci.org/hatemogi/holiday-project/builds/25843181&#34;&gt;결과 페이지&lt;/a&gt;를 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;빌드-테스트-결과-로그:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;빌드 테스트 결과 로그&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-test-result.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;상세한 빌드 로그도 살펴보고 무엇이 잘되고 잘못됐는지도 자세히 파악할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;github-저장소-readme-https-github-com-hatemogi-holiday-project-readme:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project#readme&#34;&gt;GitHub 저장소 README&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-build-status-img.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;최종 빌드 테스트의 성패에 따른 이미지 링크도 있어서, 저장소의 README파일에 링크를 걸어두면, 위와 같이 성공했을 경우, &lt;code&gt;build passing&lt;/code&gt;이라는 초록 버튼이 보이게 할 수 있다. 그리고, 해당 이미지 링크에 &lt;code&gt;branch&lt;/code&gt; 파라미터를 줘서 특정 Git 브랜치의 최종 커밋에 대한 이미지도 보일 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;heroku에-자동배포:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Heroku에 자동배포&lt;/h2&gt;

&lt;p&gt;빌드 테스트가 성공하면, 스테이징 서버에 자동으로 배포한다면 어떨까? 좀 더 과감한 접근이 가능한 경우라면, 아예, 빌드 테스트 성공 후에는 실 서비스 서버에 배포하게 하는 것도 가능하겠다. 더구나 지금처럼 가벼운 개인 프로젝트의 경우, 빌드 테스트 성공 후에는 그때그때 바로 배포하면 매우 편리할 것이다. 하지만, 우린 사려깊은 개발자이니, 우선 스테이징 서버에 자동으로 배포해보자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;의 &lt;a href=&#34;http://docs.travis-ci.com/user/deployment/heroku/&#34;&gt;Heroku Deployment&lt;/a&gt;라는 문서에 해당 내용이 친절히 안내돼 있다. 아래처럼 &lt;a href=&#34;https://github.com/travis-ci/travis.rb#readme&#34;&gt;travis CLI&lt;/a&gt;로 설정을 자동으로 추가할 수 있고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;travis setup heroku
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;바뀐 &lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-17/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;의 내용을 보면, travis CLI가 추가한 부분은 아래와 같다.&lt;/p&gt;

&lt;h3 id=&#34;travis-yml:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-17/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:
  provider: heroku
  api_key:
    secure: bbxlxzhB4AedhkiqKVnagzWVWpe+kusUbeYZhRjL1BJfzvGO0zXktzyqNvy6wANSetDgSMQL/wZsPkIcbtDFU1QzsvXxrfmc33TMFARCQ6JJpb+EHD31HluOwA/8nbtsqQsz8UXW+7jKjtuAxpo0ZzLE7KI0ckQRUKIRQAcky+I=
  app: holiday-project-staging
  on:
    repo: hatemogi/holiday-project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;중간에 &lt;code&gt;api_key&lt;/code&gt; 부분이 Heroku에 배포하기 위한 Heroku API 키를 Travis CI만 해석할 수 있게 암호화한 값이다.&lt;/p&gt;

&lt;p&gt;이렇게 설정을 마치고, GitHub에 새로운 커밋을 push 했더니, 문제없이 빌드 테스트를 마쳤고, Heroku에도 자동으로 배포됐다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-14/&#34;&gt;14일째, 수동으로 Heroku에 배포한&lt;/a&gt; 실 서비스(?) 주소와 오늘부터 Travis CI가 자동 배포하는 스테이징 서버의 주소는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;(실 서비스) &lt;a href=&#34;http://holiday-project.hatemogi.com/&#34;&gt;http://holiday-project.hatemogi.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(스테이징) &lt;a href=&#34;http://holiday-project-staging.herokuapp.com/&#34;&gt;http://holiday-project-staging.herokuapp.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;아직 둘의 차이는 없지만, 개발 과정에서 종종 차이가 있을 것이고, 실 서비스 배포 전에, 로컬 테스트와 더불어 스테이징 테스트까지도 아주 편리하게 할 수 있겠다. 그것참 개발하기 편한 세상이다.&lt;/p&gt;

&lt;p&gt;이로써, 그간 살펴보려고 모아두었던 기술 주제들은 대략적으로나마 알아보았다. 내일부터는, 본격(?) 개발 작업에 들어가려 한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 16일: 중간 점검 - 왜 이 프로젝트를 하나?</title>
      <link>http://hatemogi.com/holiday-project-day-16/</link>
      <pubDate>Thu, 22 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-16/</guid>
      <description>

&lt;p&gt;30일의 휴가 동안 개인적으로 진행하고 있는 프로젝트, 그 절반의 시간이 지났다. 사실 프로젝트라고 말하기는 어려울 수 있는 것이, 딱히 정해진 목표 결과물 없이, 그간 알아보고 싶었던 기술 주제를 공부해보고 있는 성격이 강해서, 정확히 말하면, &amp;ldquo;다양한 웹 개발 기술 셋 훑어보기 프로젝트&amp;rdquo;라고 해야 맞는 건지도 모르겠다.&lt;/p&gt;

&lt;p&gt;지난주에 딸내미 100일 떡을 돌리러 회사에 잠깐 들렀고, 오늘 또 잠시 들렀다. 그러면 지금까지 보름 동안 벌써 두 번 들른 것이다. 고작 며칠 집에서 쉬었는데, 뜻밖에도, 회사에 가고 싶었다. 어젯밤 라디오스타에 출연한 배철수 아저씨가, &amp;ldquo;방송  시간이 아니어도 방송국에서 산다&amp;rdquo;는 얘기를 했는데, 이상하게도 어느 정도 이해가 된다. 사실 나도, 제주에서 아는 사람이라고는 회사 사람들뿐이고, 공통 관심사인 &amp;lsquo;개발 얘기&amp;rsquo;를 할 만한 사람들도 그 사람들뿐이니까.&lt;/p&gt;

&lt;p&gt;어쨌든, 간만에 회사에 갔더니, 몇몇 동료 개발자분들이 내 프로젝트 글을 읽고 있다고 말해주었고, 꽤 완곡하고 정중한 표현으로 몇 말씀 해주셨으나, 냉정하게 해석하면 두 가지 질문이 많았다. (솔직히 말하면 많다기 보다, 딱 세 분이 물어봐 주셨다. ㅎ)&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;그거 뭘 하시려는 건지 모르겠어요.&lt;/li&gt;
&lt;li&gt;왜 하시는 거에요?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;딱히 깊게 생각해 보지 않고 진행한 것이라, &amp;ldquo;그냥요&amp;rdquo;라고 대답하는 것이 가장 정확하겠지만, 즉흥적으로 입에서 튀어나온 답변은 그랬다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;최근 1~2년간 개발을 하지 않다 보니, 개발이 하고 싶었어요.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;장황한-푸념:1fa7e296b3890454874fa1b56be7e1c9&#34;&gt;장황한 푸념&lt;/h2&gt;

&lt;p&gt;개발자에서 개발팀장이 된 지 2년쯤 된 것 같은데, 나를 포함한 (적어도 우리 회사에서 내 주변 대다수의) &lt;strong&gt;개발팀장은 개발을 하지 않는다&lt;/strong&gt;. 내 생각에도 개발팀장의 가장 중요한 역할은 &amp;lsquo;팀원들이 개발을 잘하도록 지원하는 것&amp;rsquo;이지, 자신이 직접 개발하는 것은 아니다. 논란과 이견의 여지가 크지만, 직접 개발하면 오히려 팀원들이 개발을 잘하는 데에 방해된다고 생각한다. 아무래도 팀장의 입김이 지나치게 세게 작용해서 그릇된 결론을 도출하기도 쉽고, 게다가 팀원들이 훨씬 더 개발을 잘하므로, 걸리적거리기만 할 수도 있다.&lt;/p&gt;

&lt;p&gt;그런 생각에서, 난 팀장이 된 뒤, 될 수 있는 대로 개발적인 이슈는 팀원들에게 위임하는 편이다. 내가 하는 일이라고는 번거로운 보고 업무를 한다거나 다른 팀에게 가서 우리 팀 서비스를 영업한다거나, 윗분들께 업무성과를 홍보한다거나, 그런 잡일을 한다. 단적으로 얘기하면, 그전에는 소스코드 에디터나 IDE, 터미널을 사용하는 시간이 많았다면, 팀장이 되고 나서는 이메일 애플리케이션을 가장 많이 쓰게 됐으니까, 얼마나 개발에서 멀어졌는지 더 얘기하지 않아도 될 것 같다.&lt;/p&gt;

&lt;p&gt;한 2년 해보니까, 그래도 팀장 역할도 꽤 잘하는 것 같다. 자동차 운전자의 80%가 본인은 평균 이상의 운전 실력을 갖추고 있다고 착각한다지 않는가? 분명 상식적으로 평균 이상은 50%에 가까워야 하는데, 80%라니&amp;hellip; 무려 30%가 얼토당토않은 착각을 하는 것이지. 아마도 내가 스스로 판단하는 팀장 역할 수행 능력도 그런 착각의 일종이겠지만, 착각은 개인의 자유니까. 이런 착각으로, 아주 많은 뛰어난 개발자들이 그냥 평범한 매니저의 길로 가는 것이 아닐까?&lt;/p&gt;

&lt;p&gt;그러나 문제는, 그 평균 이상은 충분치 않고, 적어도 개발자로 현업에서 일할 때의 수행 능력이, 팀 매니저로서 하는 수행 능력에 비해서 나았을 것 같다. 소위, &amp;ldquo;뛰어난 개발자들 멍청한 매니저로 만든다&amp;rdquo;지 않던가? 난 뛰어나지도 않으니, 얼마나 멍청한 매니저가 되었겠는가?! 그리고 무엇보다 결정적인 문제는, 개발은 잘하고 싶고, 재미도 있는데, 매니징는 잘하는 것 같지도 않고, 또 잘하고 싶지도 않다는 점이다.&lt;/p&gt;

&lt;p&gt;가까운 사람에게 이런 솔직한(?) 푸념을 늘어놓으면, 주변의 훌륭한 사람들은 그렇게 말한다. &amp;ldquo;팀장이라고 개발하지 말라는 법이 있는 건 아니잖아. 그냥 개발도 같이 해.&amp;rdquo; 오우! 그건 리더 역할을 훌륭하게 하고 있을 때 생각해 볼 수 있는 것 아닐까? 당장 매니저 역할도 제대로 못 해서 문제인데, &lt;strong&gt;사치스러운 개발&lt;/strong&gt;이라니?!&lt;/p&gt;

&lt;p&gt;개발팀장의 푸념이 길어졌는데, 그만하고 정리하면, 그렇게 &amp;ldquo;개발 현업에서 멀어지고 나니, 다시 현업이나 기술 이슈에 그리움이 커졌고, 그걸 시간내서 보충하고 싶었다&amp;rdquo;고 이유를 둘러댈 수 있겠다.&lt;/p&gt;

&lt;p&gt;그런 한편, 사실 현업 개발자일 때는, &amp;ldquo;당장 눈앞의 현업이 바빠서 새로운 기술 셋을 살펴볼 여유 시간이 없다&amp;rdquo;고 했으니, &amp;ldquo;팀장이라서 그간 개발 공부를 하지 못했다&amp;rdquo;라는 것 역시 &lt;strong&gt;그럴싸한 핑계일지도 모르겠다.&lt;/strong&gt; 의지만 있다면 할 수 있는 것일지도 모른다.&lt;/p&gt;

&lt;h2 id=&#34;이제야-중간-점검:1fa7e296b3890454874fa1b56be7e1c9&#34;&gt;이제야 중간 점검&lt;/h2&gt;

&lt;p&gt;장황했으나, 결론은,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;그냥 그간 알아보고 싶었던 주제들을 이제야 휴가기간이라는 여유를 틈타 살펴보고 있다.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정도가 될 수 있겠다. 언제 기회가 되면, &amp;ldquo;그런 생각이 있으면서도 왜 팀장직을 맡게 되었는가&amp;rdquo;에 대해서도 블로깅 해보고 싶다. 주변에 보면, 안이하게 막연히 &amp;ldquo;나이가 들어서도 계속 개발자 할래요&amp;rdquo;라는 사람들이 많아서, 어떤 점을 더 고려해야 하는지 따끔하게 알려주고 싶은 훈수 심리가 발동돼서 말이다.&lt;/p&gt;

&lt;p&gt;어쨌건, 보름간을 되돌아 보니, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-01/&#34;&gt;첫날&lt;/a&gt; 언급했던 주요 관심 주제들을 거의 다 살펴본 것 같다. 정말 뜻밖에, 부족하게나마 &amp;ldquo;매일 블로깅 해보자&amp;rdquo;는 목표도 아직은 잘 달성하고 있다. 작심삼일로 끝날 줄 알았거늘, 이런 스스로 대견한 상황이라니! 내일 travis-ci까지만 더 알아보고, 그 뒤로는 뭐라도 만들어 보는 데 주력해 보겠다.&lt;/p&gt;

&lt;p&gt;지난 보름간 가장 큰 소득을 꼽자면, D3.js를 새로이 알게 된 것과, AngularJS를 살펴본 것을 꼽을 수 있겠다. 너무 이른 판단인지 모르겠으나, 지금 jQuery나 트위터 부트스트랩이 아주 널리 쓰이듯이, 조만간 AngularJS도 웹애플리케이션 개발자라면 반드시 알고 써야할 프레임워크가 될 거라고, 감히 주제넘게, 단언한다.&lt;/p&gt;

&lt;p&gt;아, 아니다. 더 큰 소득이 있다. 그동안 자신이 얼마나 (게으르게) 개발에서 멀어져 있었고, 세상은 얼마나 더 빠르게 더 좋은 기술들이 나오고 있는지를 되새기게 된 소득이 가장 크겠다.&lt;/p&gt;

&lt;p&gt;이상, 중간 점검 끝~!&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 15일: AngularJS 코드스쿨 강좌 소개</title>
      <link>http://hatemogi.com/holiday-project-day-15/</link>
      <pubDate>Wed, 21 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-15/</guid>
      <description>&lt;p&gt;프로젝트 15일째, 오늘은 드디어 &lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;를 살펴봤다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;는 구글에서 만든 웹앱 개발을 돕는 자바스크립트 프레임워크로, 복잡한 웹애플리케이션을 만들기 쉽도록 도와준다. 호평을 들어온 터라 나도 언제 한번 써봐야지 생각했었는데, 때마침 &lt;a href=&#34;codeschool.com&#34;&gt;Code School&lt;/a&gt;에 &lt;a href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34;&gt;Angular 강의&lt;/a&gt;가 새로 올라와서 아주 편리하게 기초를 배워볼 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34;&gt;Shaping up with Angular.js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그전에는 &lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS 공식사이트&lt;/a&gt;의 튜토리얼을 조금 따라 해보다가 말았는데, 이번에는 훨씬 쉽게 기본 개념을 익혀볼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/angular-badge.png&#34; style=&#34;width: 300px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;잠깐 다른 얘기로, 영어권 개발자에게는 이런 학습 자료와 잘 정리된 온라인 강의 사이트가 유용할 것 같아 참 부럽다. 한국어 자료로도 잘 되어 있으면 참 좋겠다. 참고로, 국내에는 이고잉님의 &lt;a href=&#34;http://opentutorials.org/&#34;&gt;생활코딩&lt;/a&gt;을 비롯해 매우 훌륭한 정리가 이미 많지만, 더 다양하고 활발한 정리와 공유가 이뤄지면 좋겠다.&lt;/p&gt;

&lt;p&gt;다시 돌아와서, 아무튼, AngularJS를 써봐야겠다는 생각이 확고해졌다. 새로운 기술이나 도구를 만나면, 그게 유용할지 아닐지를 따지기도 해야겠지만, 그전에 우선 그 대상에 대한 호감이 들고나서야 하는 건데, 그런 관점에서는 일단 호감 단계는 넘어섰고, 앞으로의 웹개발에 꽤 유용하게 사용할 수 있겠다는 기대가 든다.&lt;/p&gt;

&lt;p&gt;그리고 한가지 기대 밖의 소득으로, 강의 마지막에 소개받은 앱이 있는데, 아주 마음에 들어서 바로 구매했다. &lt;a href=&#34;http://kapeli.com/dash&#34;&gt;Dash&lt;/a&gt;라는 앱인데, 각종 개발 문서들을 로컬에 받아서 오프라인 상태에서도 검색해가며 살펴볼 수 있는 맥 앱이다. 브라우저에서 북마크 찾아가며 각종 API 문서 뒤적이는 게 불편한 적이 많았는데, 이 앱 덕에 꽤 편리해질 듯하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/dash.png&#34;  style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;오늘은 강의만 듣고, 별다른 진행이나 정리를 하지 못했다.&lt;/p&gt;

&lt;p&gt;뭔가 찜찜하지만, 밤이 깊었으니, 오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 14일: Heroku에 Node.js 애플리케이션 배포</title>
      <link>http://hatemogi.com/holiday-project-day-14/</link>
      <pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-14/</guid>
      <description>

&lt;p&gt;프로젝트 14일째, 오늘은 데모 웹사이트를 만들어 올리기 위해, (1) 노드용 템플릿 엔진인 &lt;a href=&#34;http://jade-lang.com/&#34;&gt;Jade&lt;/a&gt;를 잠깐 써보고, (2) Heroku에 지금까지 만들고 있는 &lt;a href=&#34;https://github.com/hatemogi/holiday-project&#34;&gt;express 웹앱&lt;/a&gt;을 배포해봤다.&lt;/p&gt;

&lt;h2 id=&#34;node-js-템플릿-엔진-jade:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;Node.js 템플릿 엔진 - Jade&lt;/h2&gt;

&lt;p&gt;루비 쪽의 &lt;a href=&#34;http://haml.info/&#34;&gt;Haml&lt;/a&gt;과 같은 템플릿 엔진이다. 간결한 문법과 들여쓰기로, HTML/XML 태그를 여닫는 번거로움 없이 간편하게 결과 페이지를 만들 수 있다. 이하는 오늘 작성한 템플릿 레이아웃의 일부다.&lt;/p&gt;

&lt;h3 id=&#34;layout-jade-https-github-com-hatemogi-holiday-project-blob-day-14-views-layout-jade-의-일부:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-14/views/layout.jade&#34;&gt;layout.jade&lt;/a&gt;의 일부&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;doctype html
html
  head(prefix=&amp;quot;og: http://ogp.me/ns#&amp;quot;)
    meta(charset=&amp;quot;utf-8&amp;quot;)
    meta(name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;)
    title= title
    link(rel=&#39;stylesheet&#39; href=&#39;http://hatemogi.com/bower_components/bootstrap/dist/css/bootstrap.min.css&#39;)
    script(src=&#39;/bower_components/jquery/dist/jquery.min.js&#39;)
    script(src=&#39;/bower_components/bootstrap/dist/js/bootstrap.min.js&#39;)
  body
    block content
    include ga
    include github_badge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 모습인데, HTML 문서의 태그를 들여쓰기로 어느 부분까지 감싸는 것인지 표현한다. 각종 태그를 그대로 쓰면 되고, 괄호 안의 속성값이 그대로 해당 element의 속성이 된다. 중간중간 현재 문맥에 바인딩 된 값을 가져다 쓸 수 있다. 위 레이아웃에서는 &lt;code&gt;title&lt;/code&gt; 태그의 값이 그렇게 사용된다.&lt;/p&gt;

&lt;p&gt;body 태그 바로 아래에 &lt;code&gt;block content&lt;/code&gt; 부분이 실제 본문 내용이 대치/입력돼 최종 출력된다고 보면 된다. &lt;code&gt;include&lt;/code&gt;는 말 그대로 별도 템플릿을 읽는다.&lt;/p&gt;

&lt;p&gt;템플릿 엔진이야 워낙 다양하고, 어떤 언어와 웹서비스 프레임워크를 쓰느냐 만큼 개인별 호불호가 달라서, 스스로 마음에 드는 템플릿 엔진을 골라서 사용하면 된다.&lt;/p&gt;

&lt;h2 id=&#34;heroku에-배포:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;Heroku에 배포&lt;/h2&gt;

&lt;p&gt;프로젝트가 잘 진행되어, 웹 애플리케이션을 올려서 공개한다면, 아마도 &lt;a href=&#34;http://aws.amazon.com/ko/ec2/&#34;&gt;AWS EC2&lt;/a&gt;나 &lt;a href=&#34;https://cloud.google.com/products/compute-engine/&#34;&gt;Google Compute Engine&lt;/a&gt;에 직접 구축해서 올릴 테지만, 아직 그런 단계는 아니고, 이 블로그를 읽고 있는 소수의 지인께만 보여드리는 데모 웹페이지가 필요한 정도다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://heroku.com/&#34;&gt;Heroku&lt;/a&gt;는 각종 웹 애플리케이션을 올려서 서비스할 수 있는 클라우드 서비스인데, 스타트업들이 즐겨 사용하는 플랫폼이다. 개인적으로는 &lt;a href=&#34;http://hatemogi.com/saas_class/&#34;&gt;2012년에 Coursera에서 SaaS 수업&lt;/a&gt;을 들으며 써본 적이 있는데, 좋은 인상을 받았던 서비스다.&lt;/p&gt;

&lt;p&gt;로컬에서 잘 개발하고, heroku에 생성한 앱의 git 저장소 주소로 push하면 해당 애플리케이션이 배포되며, 곧바로 &lt;code&gt;앱이름.herokuapp.com&lt;/code&gt;에서 접근해 확인할 수 있다. 직접 서버를 설치하고 구동하고 관리할 필요없이 &lt;code&gt;git push heroku&lt;/code&gt;만으로 배포되고, 그 후 운영은 heroku가 알아서 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/heroku-dashboard.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;이번 데모를 위해서 최소 자원을 받았고, 개발용 Postgres 인스턴스도 add-on으로 붙인 화면이다. 비록 1만 레코드까지만 쓸 수 있는, 정말 개발시연용이지만, 지금의 목표에는 충분히 활용할 수 있다. 무엇보다도, 데모를 위한 규모에서는 &lt;strong&gt;무료로 서비스를 이용&lt;/strong&gt;할 수 있다. 보이는가? 월 예상비용 $0.00 !!!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/hatemogi/status/399814963360849920&#34;&gt;개인적으로는 프로젝트 초기에는 그냥 간단히 가볍게 SQLite 활용하자는 마인드&lt;/a&gt;지만, Heroku 특성상, 일단 무료 Postgres를 써보기로 한다.&lt;/p&gt;

&lt;p&gt;배포 중에 발생한 한가지 문제는, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-04/&#34;&gt;프로젝트 4일 차에 알아본 Bower&lt;/a&gt;로 가져다 쓴 Bootstrap과 jQuery를 Heroku에 배포한 앱에서는 설치되지 않았던 점이 있다. 프로젝트 배포하고 &lt;code&gt;bower install&lt;/code&gt;을 실행해야 하는데, Heroku에서 기본으로 그 커맨드를 실행할 이유는 없는 것. 검색을 좀 해보니, 무슨 Heroku의 빌드팩이라는 걸 만들어서 해결하는 방법이 있던데, 뭘 그렇게까지 해야 하나 싶어서 좀 더 검색해보니, &lt;a href=&#34;http://xseignard.github.io/2013/02/18/use-bower-with-heroku/&#34;&gt;아주 간단하게 해결한 방법&lt;/a&gt;을 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;의 &lt;code&gt;scripts&lt;/code&gt; 부분에 &lt;code&gt;postinstall&lt;/code&gt;이라는 항목에, 실행할 스크립트를 넣어 놓으면 &lt;code&gt;npm install&lt;/code&gt;이 진행되고 나서 이 스크립트를 실행하게 되는데, 이 부분을 이용하는 것.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node ./bin/www&amp;quot;,
    &amp;quot;karma&amp;quot;: &amp;quot;./node_modules/karma/bin/karma start&amp;quot;,
    &amp;quot;spec&amp;quot;: &amp;quot;./node_modules/jasmine-node/bin/jasmine-node --coffee --verbose spec&amp;quot;,
    &amp;quot;postinstall&amp;quot;: &amp;quot;./node_modules/bower/bin/bower install&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 간단하게 웹서비스 실행 전에 &lt;code&gt;bower install&lt;/code&gt;을 실행할 수 있다. 한 가지 단점은, 이 커맨드를 실행하기 위해, (실제 실행 때에는 필요하지 않은) bower 의존성을 걸어야 한다는 점이 있으나, 무시할만하다.&lt;/p&gt;

&lt;p&gt;그렇게 해서, 결국 데모 앱을 준비했다. 아직 뭐 하는 기능은 없고, 단지 Heroku에 &lt;strong&gt;텅 빈&lt;/strong&gt; express 앱을 띄워 놓은 것. 차차 여기에 살을 붙이기로 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://holiday-project.hatemogi.com/&#34;&gt;http://holiday-project.hatemogi.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(위 주소에 heroku 서비스를 올려놓았으나, 아직은 방문하지 말아달라. ^^;)&lt;/p&gt;

&lt;p&gt;한가지 전혀 다른 얘기로, Heroku add-on을 살펴보다가 Redis addon을 슬쩍 봤는데, 아래 캡처이미지에 보이듯, 3만8천 개 인스턴스를 서비스하고 있단다. 회사 업무로 우리 팀이 하는 일 중 하나가, 사내에 Redis 인스턴스 클라우드스럽게(?) 제공해주고 운영하는 일인데, 이거 외부에서 장사해도 될만한 일이었구나하는 뒤늦은 아쉬움이 든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/redis-to-go.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;3만8천 개라니&amp;hellip; 대단하다. 장사 잘되는구나?!&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>