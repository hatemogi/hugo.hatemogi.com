<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hatemogi&#39;s blog</title>
    <link>http://hatemogi.com/post/</link>
    <description>Recent content in Posts on hatemogi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 13 Jul 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://hatemogi.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>팀장직 내려놓기</title>
      <link>http://hatemogi.com/post/2014/0713-no-more-managing/</link>
      <pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/post/2014/0713-no-more-managing/</guid>
      <description>&lt;p&gt;2년 남짓 맡아왔던 개발팀장직을 내려놓았다. 연초부터 고민했던 일인데, 출산휴가와 안식휴가 2달을 틈타 고민도 더 하고, 결정도 미뤄왔던 일이다.&lt;/p&gt;

&lt;p&gt;주변에 보면 적지 않은 개발자가, 순수(?) 개발 일을 계속하고자 하지만, 결국 나이가 들면 안팍의 압력에 못 이기고, 매니저의 길로 들어서는 모습을 흔히 볼 수 있다. 나역시 어느정도 우리회사에서의 적정 나이(?)가 되어 팀장직을 맡게된 것이기도 했던 것같다.&lt;/p&gt;

&lt;p&gt;개발력이 뛰어난 팀원들과 함께 일할 수 있어 즐거운 시간이었고, 나름의 성과도 잘 드러났던 것 같아서 감사한 마음이 크다. 어느 순간이 되어 내가 아니더라도 우리 팀은 잘 지낼 수 있는 시기가 되었고, 나는 다시 개발자로 일하고자 내려오기로 했다.&lt;/p&gt;

&lt;p&gt;사실 팀장이 되기 전에는 팀장은 역할일 뿐, 위아래의 개념은 없다고 생각했는데, 사실상 겪어보니, 결국은 위아래의 환경이었다. 내가 위가 아니라고 생각해도, 팀원들은 나를 위라고 생각하고, 내가 조직도상 윗사람을 내 위가 아니라고 생각해도, 그 사람은 나를 아랫사람이라고 생각한다.&lt;/p&gt;

&lt;p&gt;하다보니 역할에 익숙해지기도 하고, 어떻게 하면 더 잘해볼 수 있을지 보이기도 했지만, 내가 잘하고 싶고, 즐겨하는 일은 개발이었지, 리딩이나 매니징이 아니라는 게 시간이 갈 수록 분명해졌다.&lt;/p&gt;

&lt;p&gt;어쨋건 운좋게(?) 다시 개발자로 조직도상 위치는 바뀌었지만, 아직 어떤 개발 일을 하게 될지는 미지수. 이제 이렇게 머리가 굵어져서, 그냥 아무 개발이나 할 수도 없고, 영락없이 꿔다 놓은 보릿자루 신세다.&lt;/p&gt;

&lt;p&gt;어떻게 자리 잡아갈지 두고 볼 일이다. 물론, 결국 자리를 못잡을 수도 있지만, 크게 걱정하지는 않는다. 어느정도 감안했던 일이다. 오히려, 반대로, 계속 매니저 트리를 탔다면, 그걸 더 걱정해야할 상황이었다.&lt;/p&gt;

&lt;p&gt;의외로, 이제야 조금 마음이 놓인다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 마지막날: 결과물 미리보기</title>
      <link>http://hatemogi.com/holiday-project-day-last/</link>
      <pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-last/</guid>
      <description>

&lt;p&gt;지금은 30여 일간의 휴가 마지막 날 밤이다. 한 달여 동안 알아보고 싶었던 주제들을 간략히나마 공부했고, 마지막 며칠 동안은 그 공부한 내용을 활용해보고자 간단한 웹서비스를 개발해 보고자 했다.&lt;/p&gt;

&lt;p&gt;처음의 목표 중 하나는 30일 동안 매일 블로그 글을 남기는 것도 있었는데, 마지막에 잘 지키지 못해서 아쉽지만, 그래도, 한가지 개발 주제도 잡았고, AngularJS나 D3같은 앞으로도 깊이 살펴볼 주제들을 찾게 돼서 좋았다.&lt;/p&gt;

&lt;h2 id=&#34;gvdoodle:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;gvDoodle&lt;/h2&gt;

&lt;p&gt;어떤 것을 개발할까 몇가지 머릿속으로만 고민하다가, 결국 주제로 잡은 것은&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;웹에서 &lt;a href=&#34;http://www.graphviz.org&#34;&gt;Graphviz&lt;/a&gt; 파일을 작성하고, 바로 확인해보고, 링크로 공유할 수 있는 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이다. &lt;a href=&#34;http://www.graphviz.org&#34;&gt;Graphviz&lt;/a&gt;를 온라인에서 실험해볼 수 있고, 생성한 .svg파일은 웹서비스로 제공해줘서,  외부의 다른 웹페이지 어디에서라도 HTML &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그로 걸어서 쓸 수 있다. &lt;a href=&#34;http://jsfiddle.net&#34;&gt;JSFiddle&lt;/a&gt;과 비슷한 개념의 웹서비스다.&lt;/p&gt;

&lt;p&gt;이름 하여, gv (graphviz)로 낙서(doodle)해본다는 의미로, gvdoodle!&lt;/p&gt;

&lt;h2 id=&#34;미리보기:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;미리보기&lt;/h2&gt;

&lt;p&gt;아직 너무 미흡해서, 제대로 소개하기도 모자란 단계다. 이 글을 작성하는 시점 기준, 아직 &lt;code&gt;Save&lt;/code&gt;도 안되고, 아무리 데스크톱 화면을 목표로 만들기는 했지만, 모바일에서 화면 깨지고 난리도 아님. 그래도, 아래 사이트에서 어떤 내용인지 미리 확인해 볼 수 있도록 준비했다. 왼쪽의 Example에서 .gv문서 예제 고르고, &lt;code&gt;Run&lt;/code&gt;버튼 실행해보면 즉석에서 결과 그래프를 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://preview.gvdoodle.com&#34;&gt;http://preview.gvdoodle.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;물론, 틈나는 대로 완성도를 높여나갈 예정이다.
오는 주말이 지나면, 다시 제대로 소개할 수 있기를 기대한다.&lt;/p&gt;

&lt;p&gt;소스코드는 아래 주소에 공개하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/gvdoodle&#34;&gt;https://github.com/hatemogi/gvdoodle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;휴가-끝:952ba40377a2ec47393f6bdb2293fef2&#34;&gt;휴가 끝&lt;/h2&gt;

&lt;p&gt;매우 아쉽지만, 휴가는 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교</title>
      <link>http://hatemogi.com/holiday-project-day-22/</link>
      <pubDate>Sat, 31 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-22/</guid>
      <description>

&lt;p&gt;오늘은 프로젝트 22일째 작성한 Async.js 코드와 Promise 코드를 비교해본다.&lt;/p&gt;

&lt;h2 id=&#34;콜백-중첩의-늪:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;콜백 중첩의 늪&lt;/h2&gt;

&lt;p&gt;자바스크립트 자체만으로도 그렇지만, 특히 Node.js 환경은 비동기 I/O가 중요해서, 콜백 방식의 함수 호출이 자주 활용되며, 그 호출 간의 중첩도 잦다. 즉, 콜백에서 다시 콜백 걸고 또 콜백 거는, 계속 타고들어가는 콜백이 필요한 경우가 많다.&lt;/p&gt;

&lt;p&gt;이 연속되는 콜백을 그냥 평범하게 코딩하면, 마치 예외처리 (try-catch-finally) 구문 없이 코딩하는 것처럼, 예외 처리에 대한 코드가 중간중간 끼어들어서 정상적인 로직 코드가 묻혀버리기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-10/&#34;&gt;10일째 작성했던 코드를 다시 예로 들어보자.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)

describe &#39;[CoffeeScript] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    nodegit.Repo.open &amp;quot;git/nodegit&amp;quot;, (err, repo) -&amp;gt;
      return done(err) if err
      expect(repo.path()).toMatch /\.git\/$/
      repo.getCommit sha, (err, entry) -&amp;gt;
        return done(err) if err
        expect(entry.sha()).toEqual sha    
        done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보통의 비동기 콜백 함수들이 파라미터로 &lt;code&gt;(err, result)&lt;/code&gt;를 받는 형태이고, 처리 과정에서 에러가 발생하면 err에 에러 관련 값이 들어오고, 정상처리됐으면 null이 온다. 그리고, result에 결과값이 담겨있는 형태다.&lt;/p&gt;

&lt;p&gt;위 코드의 중간마다 있는 &lt;code&gt;return done(err) if err&lt;/code&gt; 부분이 에러 상황에 Jasmine 프레임워크에 에러 결과를 리포팅하겠다는 코드인데, 콜백 도입부마다 똑같은 코드를 넣어서 전체 코드가 눈에 잘 띄지 않게 됐다.&lt;/p&gt;

&lt;h2 id=&#34;promise와-async-js:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;Promise와 Async.js&lt;/h2&gt;

&lt;p&gt;이 불편함을 해결하는 방법이 여럿 있을 것 같은데, 그중에서도 Async.js와 Promise를 살펴봤다. Async.js는 비동기 호출에 편리한 유틸리티 함수들이 제공되는 라이브러리여서, npm등으로 잘 가져다가 사용하면 된다. 평범한 자바스크립트 라이브러리라 브라우저에서 사용해도 된다. 한편, Promise는 사실 자바스크립트(ECMAScript) 스펙에 포함되는 규약인데, 아직 지원하지 않는 자바스크립트 엔진을 위해, 별도 구현체 중에 하나 가져다가 쓰면 된다.&lt;/p&gt;

&lt;p&gt;콜백 방식의 호출은 물론, Promise와 Async.js도 익숙치 않기 때문에, 연습해볼 겸 똑같은 코드를 둘다의 방식으로 작성해봤다. nodegit으로 git 저장소를 열고, 커밋 두 개에 엮인 트리를 찾아서 둘 사이 차이(패치 크기)를 알아보는 메소드를 작성했고, 코드는 아래와 같다.&lt;/p&gt;

&lt;h3 id=&#34;async로-작성한-코드-https-github-com-hatemogi-holiday-project-blob-day-22-spec-nodegit-repo-async-spec-coffee:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_async_spec.coffee&#34;&gt;Async로 작성한 코드&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
async = require(&amp;quot;async&amp;quot;)
_ = require(&amp;quot;underscore&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

describe &#39;[CoffeeScript w/async.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    open = nodegit.Repo.open
    async.waterfall [
      open.bind(open, nodegitPath)
      (repo, cb) -&amp;gt;
        expect(repo.path()).toMatch /\/git\/nodegit\/$/
        repo.getCommit sha, cb
      (entry, cb) -&amp;gt;
        expect(entry.sha()).toEqual sha
        cb null
    ], done

  it &#39;diff 실행해보기&#39;, (done) -&amp;gt;
    async.waterfall [
      (cb) -&amp;gt;
        nodegit.Repo.open nodegitPath, cb
      (repo, cb) -&amp;gt;
        async.parallel [
          repo.getCommit.bind(repo, &amp;quot;33c7b930acc13148ef6f05df56f9b8a5c3578a57&amp;quot;),
          repo.getCommit.bind(repo, &amp;quot;c3e4be4448d2a99917431d3be972ca262805f989&amp;quot;)
        ], (err, commits) -&amp;gt; cb(err, repo, commits)
      (repo, commits, cb) -&amp;gt;
        async.parallel [
          repo.getTree.bind(repo, commits[0].treeId()),
          repo.getTree.bind(repo, commits[1].treeId())
        ], cb
      (trees, cb) -&amp;gt;
        trees[0].diff trees[1], cb
      (diff, cb) -&amp;gt;
        expect(_.reduce(diff.patches(), ((m, p) -&amp;gt; m + p.size()), 0)).toBe(2)
        cb null
    ], done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;async.waterfall&lt;/code&gt;과 &lt;code&gt;async.parallel&lt;/code&gt; 함수를 사용해서 작성했고, 전체적 흐름은 일관되고 편리하다. 하지만, 콜백 꼬리 &lt;code&gt;cb&lt;/code&gt;를 늘 달고 다녀야 하는 아쉬움(?)이 있다.&lt;/p&gt;

&lt;h3 id=&#34;promise로-작성한-코드-https-github-com-hatemogi-holiday-project-blob-day-22-spec-nodegit-repo-promise-spec-coffee:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_promise_spec.coffee&#34;&gt;Promise로 작성한 코드&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
Promise = require(&amp;quot;promise&amp;quot;)
_ = require(&amp;quot;underscore&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

openRepo = Promise.denodeify(nodegit.Repo.open)
getCommit = (repo) -&amp;gt;
  Promise.denodeify(repo.getCommit.bind(repo))
getTree = (repo) -&amp;gt;
  Promise.denodeify(repo.getTree.bind(repo))
getDiff = (tree) -&amp;gt;
  Promise.denodeify(tree.diff.bind(tree))

describe &#39;[CoffeeScript w/promise.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      expect(repo.path()).toMatch /\/git\/nodegit\/$/
      getCommit(repo)(sha)
    ).then((entry) -&amp;gt;
      expect(entry.sha()).toEqual sha
    ).then done, done

  it &#39;diff 실행해보기&#39;, (done) -&amp;gt;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      Promise.all([
        getCommit(repo)(&amp;quot;33c7b930acc13148ef6f05df56f9b8a5c3578a57&amp;quot;),
        getCommit(repo)(&amp;quot;c3e4be4448d2a99917431d3be972ca262805f989&amp;quot;)
      ]).then((c) -&amp;gt;
        Promise.all [
          getTree(repo)(c[0].treeId()),
          getTree(repo)(c[1].treeId())
        ]
      )
    ).then((trees) -&amp;gt;
      getDiff(trees[0])(trees[1])
    ).then((diff) -&amp;gt;
      patchsize = _.reduce(diff.patches(), ((m, p) -&amp;gt; m + p.size()), 0)
      expect(patchsize).toBe(2)
    ).then done, done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Promise의 경우, 전체 메시지를 마치 보통 동기 호출 스타일로 작성하자는 것이 포인트인데, 어떤 비동기 처리 뒤에 &lt;code&gt;then&lt;/code&gt; 함수를 붙여서, 성공한 경우와 실패한 경우의 처리를 한다. 계속 연결해서 (chaining) 사용하는 것이 핵심이라면 핵심이다.&lt;/p&gt;

&lt;p&gt;위 코드는 &lt;code&gt;Promise.then&lt;/code&gt;과 &lt;code&gt;Promise.all&lt;/code&gt;을 사용했다. 결국 두 코드 스타일이 비슷해졌다. 팀 동료들에게 물어보니, Async가 더 보기 좋다는 사람도 있던데, 내 경우에는 Promise가 좋게 느껴지는 면도 있다고 생각한다. 우선 늘 쫓아다녀야 하는 콜백 함수 꼬리표를 떼놓고 생각할 수 있고, 코드의 흐름이 차례로 흐르는 방식이 평소 동기화 방식 코딩을 할 때와 크게 다르지 않아서 좋다.&lt;/p&gt;

&lt;h2 id=&#34;그러나-둘-중-하나를-쓴다면:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;그러나, 둘 중 하나를 쓴다면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Async.js의 경우, 비동기 호출과 관련한 다양한 유틸리티가 많아서, 1:1로의 비교는 어렵지만, waterfall에 한정 지어 비교해본다면 결론이 쉽게 난다.&lt;/p&gt;

&lt;p&gt;Promise 스타일이 내게는 더 좋지만, 문제는, 이미 널리 있는 자바스크립트 라이브러리들이나 Node.js의 기본 API들이 일반 콜백 방식으로만 되어있지, Promise 스타일로 준비된 것이 아니어서, 위 코드에서처럼 &lt;code&gt;Promise.denodeify&lt;/code&gt;같은 유틸리티 함수로 Promise화 한다거나, 아니면 직접 Promise 함수로 만들어 놔야 한다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;한마디로, 이미 통용되는 코드를 그대로 활용하기에는 Async.js가 좋은 것 같다. Promise 스타일이 더 널리 쓰이기 시작해서 다른 API들도 그 스타일대로 쓸 수 있게 되면 적극적으로 활용해보기 좋다고 생각한다. 그전까지는 Async.js의 활용도가 더 높을 수밖에 없을 것 같다.&lt;/p&gt;

&lt;h2 id=&#34;한편-콜백의-불편함을-감수해야-하나:3468b0b5e250ef40d4aaff028885b8d2&#34;&gt;한편, 콜백의 불편함을 감수해야 하나?&lt;/h2&gt;

&lt;p&gt;한편, 조금 원론적인 얘기로, 비동기 코딩으로 왜 콜백의 불편함을 감수해야 할까? 자바스크립트 코딩할 때나, Node.js 코딩에서도 마찬가지로 그냥 동기화 방식으로 코딩하면 안 될까? 물론 된다. 하지만, 동기화 함수를 만날 때마다 블럭킹이 일어나면, 다른 코드가 동시에 실행될 수 없으므로, 클라이언트 코드의 경우 화면 응답성 등이 떨어질 것이고, 서버 코드의 경우 동시에 여러 사용자 처리를 할 수 없을 것이다.&lt;/p&gt;

&lt;p&gt;즉, 한마디로 동시성(concurrency) 확보를 위해 비동기 I/O 호출을 하게 되는 것인데, 사실 따지고 보면 기존에 JAVA 등으로 멀티쓰레딩 처리를 했던 것도 마찬가지로 동시성 확보를 위해 하는 일인데, 그 멀티 쓰레드 처리를 잘하기 위해 임계영역(critical section)을  잘 관리해야 하며, 신경 써야 할 점도 많다.&lt;/p&gt;

&lt;p&gt;어찌 보면 멀티쓰레드로 개발하는 것이, 당장엔 편해 보이지만 자칫하면 동시 사용자가 몰렸을 때 제대로 처리되지 않아 쓰레드 안정성(thread-safety)이 깨진 경우의 문제가 발생한다거나 하는 심각한 문제로의 발전 가능성이 있다. 그런 면에서는 콜백 처리의 불편함쯤이야 한번 감수하면 뒤탈은 적은 방식일지도 모른다.&lt;/p&gt;

&lt;p&gt;이상으로, Promise와 Async.js로 &lt;strong&gt;콜백 중첩 문제&lt;/strong&gt;를 해결해보았다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 21일: AngularJS 컨트롤러 테스트</title>
      <link>http://hatemogi.com/holiday-project-day-21/</link>
      <pubDate>Thu, 29 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-21/</guid>
      <description>

&lt;p&gt;이 글을 작성하는 지금은, 개인 프로젝트 23일째, 지난 21일째부터 정리하지 못한 밀린 숙제를 한다.&lt;/p&gt;

&lt;h2 id=&#34;숙제가-밀린-이유:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;숙제가 밀린 이유&lt;/h2&gt;

&lt;p&gt;21일째에는 AngularJS 코드를 테스트하려는 노력을 기울이다가, 블로그로 정리해야 할, 밤늦은 시간에 회사 동료들을 만나러 나갔다. 합병 소식에 허전해서였을까? 같은 단지에 사는 후배이자 동료를 불러봤는데, 마침 나올 수 있다고 했고, 그렇게 한 명 두 명 즉흥적으로 불러봤는데, 결국 5명이 모여서 늦은 시간까지 시끄럽게 떠들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/post/holiday-project/kcircle_hagun_jhban.jpg&#34; style=&#34;width: 400px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;한 명 더 왔었는데, 그가 왔을 때 이미 난 사진을 찍을 만한 상황이 아니었던지라, 이 사진이 전부다. 사진 잘 나왔다. 모두 다음의 탑클래스 개발자들이다. 치맥을 먹으면서도 &lt;code&gt;git stash&lt;/code&gt;와 Scala의 immutable 변수 &lt;code&gt;val&lt;/code&gt;을 논하는 천상 개발자들이다.&lt;/p&gt;

&lt;p&gt;아무튼 즐거운 시간을 보내고 집에 돌아왔는데, 만취 상태라서 프로젝트 기록을 남기기는커녕 다음 날까지도 숙취에 정신을 못 차리고, 이제야 뒤늦은 숙제를 다시 시작했다.&lt;/p&gt;

&lt;h2 id=&#34;angularjs-테스트-코드:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;AngularJS 테스트 코드&lt;/h2&gt;

&lt;p&gt;AngularJS 코드 스쿨 강의를 듣기 전에는 AngularJS는 조금 거창한 SPA (단일 페이지 웹 앱)에나 써볼 만한 거창한 프레임워크라고 생각했다. 강의를 듣고 나서야, SPA를 위해서도 좋지만, 멀티 페이지로 작성하더라도, 뷰와 로직을 잘 분리해 낼 수 있는 점과, 테스트를 잘할 수 있도록 준비돼 있다는 점이 훌륭하다는 것을 알게 됐다. 아예 템플릿 프로젝트 &lt;a href=&#34;https://github.com/angular/angular-seed&#34;&gt;angular-seed&lt;/a&gt;에 테스트 코드가 작성된 예제가 있다.&lt;/p&gt;

&lt;p&gt;그 예제 코드와 문서를 조금 살펴보고 나서 간단히나마 컨트롤러 테스트케이스를 작성할 수 있었다.&lt;/p&gt;

&lt;h3 id=&#34;angular-spec-js-https-github-com-hatemogi-holiday-project-blob-day-21-public-spec-angular-spec-js:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-21/public/spec/angular_spec.js&#34;&gt;angular_spec.js&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;describe(&#39;angular 컨텍스트&#39;, function() {
  beforeEach(module(&amp;quot;holiday&amp;quot;));
  it(&amp;quot;버전 확인&amp;quot;, inject(function($controller) {
    expect(angular.version).toBeDefined();
    expect(angular.version.full).toEqual(&amp;quot;1.3.0-beta.8&amp;quot;);
    console.log($controller(&amp;quot;LoginCtrl&amp;quot;));
    expect($controller(&amp;quot;LoginCtrl&amp;quot;).welcome).toEqual(&amp;quot;환영합니다&amp;quot;);
  }));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적인 Jasmine 스펙 코드와 다른 점은 &lt;code&gt;beforeEach&lt;/code&gt;에 있는 &lt;code&gt;module&lt;/code&gt;이라는 함수와, &lt;code&gt;it&lt;/code&gt;에 걸려있는 &lt;code&gt;inject&lt;/code&gt;라는 함수다. 이 둘 다, &lt;a href=&#34;https://github.com/angular/bower-angular-mocks&#34;&gt;angular-mocks&lt;/a&gt; 모듈이 제공해주는 함수로, 테스트를 위해 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;module(모듈명)&lt;/code&gt; 함수는, 현재 Karma 환경에 로드된 AngularJS 앱을 기준으로 모듈을 찾아서 이하 테스트 케이스를 실행할 때 준비해준다. &lt;code&gt;inject&lt;/code&gt; 함수는 콜백에서 &lt;code&gt;$controller&lt;/code&gt; 파라미터를 받아서, 특정 컨트롤러를 받아올 수 있게 한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code&gt;$controller(&amp;quot;LoginCtrl&amp;quot;).welcome&lt;/code&gt;은, &lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-21/public/assets/app.js.coffee&#34;&gt;app.js.coffee&lt;/a&gt;에 선언한 컨트롤러의 welcome 속성을 읽는다.&lt;/p&gt;

&lt;p&gt;컨트롤러뿐 아니라, 필터나 디렉티브에 대한 테스트 케이스도 &lt;a href=&#34;https://github.com/angular/angular-seed/tree/master/test/unit&#34;&gt;angular-seed 프로젝트에서 예제&lt;/a&gt;를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;사실 테스트를 자동화한다는 것이 종종 생각만큼 쉽지 않고, 어떤 부분에서는 포기하게 되기 쉬운데, AngularJS가 이 정도로 친절하게 준비해주었으니, 그전보다는 공격적으로 더 많은 부분에서 테스트를 자동화해놓을 수 있겠다.&lt;/p&gt;

&lt;h2 id=&#34;promise와-async:0e9ecd02e6cef4cd5b278fbd6fbce4df&#34;&gt;Promise와 Async&lt;/h2&gt;

&lt;p&gt;AngularJS의 컨트롤러 스펙을 간단히 작성해보고 뿌듯한 마음으로, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-20/&#34;&gt;20일째 조금 알아본 Promise&lt;/a&gt;에 대해서도 더 알아보기 시작했다. &lt;a href=&#34;holiday-project-day-10/&#34;&gt;10일째 콜백 중첩을 풀기 위해 사용했던 Async.js&lt;/a&gt;와 비교해보고 싶었다. 어떨 때 어떻게 어느 것을 사용하면 좋을지 궁금했던 것인데, 둘 다 작성해보고 결국 마음에 드는 결론을 얻은 것은 프로젝트 22일째였다. 22일째 기록에 해당 내용을 정리하기로 한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 20일: 회사의 합병 소식</title>
      <link>http://hatemogi.com/holiday-project-day-20/</link>
      <pubDate>Mon, 26 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-20/</guid>
      <description>

&lt;p&gt;개인 프로젝트 20일째, 오늘은 내가 근무하는 회사가 다른 회사와 합병한다고 공시가 났다.&lt;/p&gt;

&lt;p&gt;겉으로야 합병이지만, 사실상 내용을 열어보면 우리가 인수당하는 입장이고, 앞으로 어떻게 될지는 알 수 없다. 당장 직속상관이 바뀌어도 업무가 확 바뀌는 것이 당연한데, 심지어 최대 주주가 바뀌는 일이니, 변화가 없을 수야 없겠지. 10년간 우리 회사가 다른 회사를 인수하거나 분사하는 것을 지켜봐 왔지만, 피인수는 처음이다. 나름 다채로운 근로자 생활이 되려나 보다.&lt;/p&gt;

&lt;p&gt;회사 분위기도 살피고, 사장님 발표도 들으러 잠시 출근했다. 출근한 김에, 팀원들에게 &lt;a href=&#34;http://hatemogi.com/holiday-project-day-19/&#34;&gt;어제 알아본 RequireJS&lt;/a&gt;와, Async와 Promise에 대해서도 물어봤다. 팀원들도 다행히 아직은 큰 동요가 없다, 아직 뭐 실감 날 일은 없으니까. 나도 아직은 멍하니 잘 모르겠고 말이다.&lt;/p&gt;

&lt;h2 id=&#34;amd-잘-쓰고-있나:d31268641f886a2ce4116b78b1519f75&#34;&gt;AMD 잘 쓰고 있나?&lt;/h2&gt;

&lt;p&gt;합병 관련해서야 내가 할 수 있는 일은 따로 없을 테고, 개인 프로젝트 얘기로 돌아오자.  이미 Node.js로 사내 서비스를 개발하고 있는 팀원들에게 물어보니, 아직 RequireJS같은 AMD를 쓰고 있지는 않았고, Promise 역시 스펙 정도만 보고, 실제로 써보지는 않은 단계였다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;minify 해서 다 로드해놓으면 되죠. JS 파일 다 합쳐봐야 얼마나 되나요? 그걸 굳이 나눠서 로드할 필요 있나요?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;맞는 말이다. 그래 봐야 텍스트 파일 아닌가? 신속한 네트워크 환경에서 텍스트 파일, 그것도 gzip으로 묶으면 이미지 파일 크기 정도인데, 그걸 어렵사리 lazy loading 하겠다고 노력하는 것도 지나친 수고일 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;promise는:d31268641f886a2ce4116b78b1519f75&#34;&gt;Promise는?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-10/&#34;&gt;10일차에 알아본 Async.js로 콜백 중첩을 푸는 방법&lt;/a&gt;에 대해서도 찜찜한 구석이 있어서, 다른 대안인 Promise에 대해서도 물어봤다. 한 명은 Promise는 오버엔지니어링인 것 같고, Async.js를 만족스럽게 쓰고 있다 했고, 한 명은, Promise를 써보지는 않고 스펙만 보았으나, 괜찮아 보인다고 했다.&lt;/p&gt;

&lt;p&gt;아직 모르는 입장에서는 남의 의견이 궁금하고, 또 중요하지만, 스스로 느끼기에도 async.waterfall도 아직 콜백 지옥을 완전히 해결해주지 못하는 것 같아서, Promise 관련해서도 조금 더 봤다. 스펙이 정리되고 있는 단계인데, 아직 지원하지 않는 JS엔진들이 더러 있어서, 그걸 메꿔주는 모듈들이 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://promisejs.org/&#34;&gt;http://promisejs.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffee&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
Promise = require(&amp;quot;promise&amp;quot;)

nodegitPath = &amp;quot;.git/modules/git/nodegit/&amp;quot;

openRepo = Promise.denodeify(nodegit.Repo.open)

describe &#39;[CoffeeScript w/promise.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    openRepo(nodegitPath).then((repo) -&amp;gt;
      expect(repo.path()).toMatch /\/git\/nodegit\/$/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nodegit.Repo&lt;/code&gt;의 &lt;code&gt;open&lt;/code&gt;이  일반 콜백 방식의 함수이고, 이걸 &lt;code&gt;Promise&lt;/code&gt; 식으로 바꿔서 호출하면, &lt;code&gt;then()&lt;/code&gt;에서 성공했을 경우의 결과 값으로 그다음 진행을 할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 한 단계의 콜백은 쉽게 &lt;code&gt;Promise.then()&lt;/code&gt; 으로 풀어쓰는 걸 알겠는데, waterfall을 해결하는 방법은 아직 와 닿지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://trevorburnham.com/presentations/flow-control-with-promises/&#34;&gt;http://trevorburnham.com/presentations/flow-control-with-promises/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기에 괜찮은 슬라이드 자료를 찾았다. 틈날 때 다시 공을 들여 읽어봐야겠다.&lt;/p&gt;

&lt;h2 id=&#34;coffeescript:d31268641f886a2ce4116b78b1519f75&#34;&gt;&lt;a href=&#34;http://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;또 한가지, 물어봤다. 커피스크립트는 어떻게 쓰고 있는지. 클라이언트 측 JS를 위해서야 컴파일도 미리 해놓고 최소화하는 것도 중요할 테니 미리미리 컴파일한다고 하더라도, 서버 측에서까지 매번 미리 컴파일하며, 각 커피 소스마다 JS파일 따로 만들어 놓는 게 여간 번거롭지 않았다. Ruby로 개발할 때야 신경 쓰지 않았다, 클라이언트 측 커피 코드만 컴파일했었으니까.&lt;/p&gt;

&lt;p&gt;어쨌건, 커피를 즐겨 쓰는 팀원 분의 의견은, 그냥 서버 실행을 &lt;code&gt;node&lt;/code&gt;가 아닌 &lt;code&gt;coffee&lt;/code&gt;로 한다는 것. 노드로 했을 경우에도, 한 줄의 설정으로 그다음 &lt;code&gt;require&lt;/code&gt;부터는 커피스크립트 소스를 그대로 읽을 수 있으니, 최초 진입 소스만 JS로 해도 되고, 아니면 최초 실행부터 아예 &lt;code&gt;coffee&lt;/code&gt;로 하면 최초 진입 소스와 그 후 require 모두 커피스크립트를 그대로 활용할 수 있다. 그래 그게 낫겠다. 서버 측이야, 떠 있는 애플리케이션이 계속 재활용되니까, 클라이언트 측처럼 매 클라이언트가 매번 컴파일 해야하는 것도 아니고 큰 부담 없겠다.&lt;/p&gt;

&lt;p&gt;지금까지 프로젝트 소스에는 커피스크립트와 JS를 혼용했는데, 오늘부로, 서버 측 코드는 커피스크립트로 통일했다. &lt;a href=&#34;http://js2coffee.org/&#34;&gt;js2coffee&lt;/a&gt;로 변환하고, 눈으로 직접보고 아주 약간씩만 손봤다.&lt;/p&gt;

&lt;p&gt;클라이언트 측 소스는 원래 하던 대로 커피스크립트 파일을 &lt;code&gt;asset&lt;/code&gt; 디렉터리에 두고, 그때그때 JS 파일로 변환하는 방식을 유지하기로 한다.&lt;/p&gt;

&lt;h2 id=&#34;프로젝트는-지지부진:d31268641f886a2ce4116b78b1519f75&#34;&gt;프로젝트는 지지부진&lt;/h2&gt;

&lt;p&gt;오늘의 성과는, 커피스크립트로 통일 전환한 것이 전부다. Promise라도 조금 더 이해할 수 있었으면 정리할 내용이 있었을 것 같은데 아쉽다. 합병 소식에 어수선했다고 얘기하면 핑계겠지.&lt;/p&gt;

&lt;p&gt;아! 그래서 결국 AMD를 쓰는 것에 대한 오늘의 방안은, D3.js를 비롯한 대부분은 AMD 방식으로 로딩하고, AngularJS만 일반 동기식으로 로딩하자는 것이다. AngularJS도 익숙하지 않고, AMD방식의 RequireJS도 익숙치 않아서, 어딘가 문제가 발생하면, 두 부분 중 어디서 잘못했는지 파악하기가 어렵다. 따라서 Angular만이라도 일반적(!)으로 로딩해서, 우선 문제 범위를 줄여놓고 진행하다가, 익숙해지면, 다시 비동기 로딩으로 전환하는 방법을 택하겠다.&lt;/p&gt;

&lt;p&gt;어떤 개발이든 마찬가지다. 무언가를 변경하거나 새로 할 때는, 불투명한 범위를 최소화해놓고, 부분과 단계별로 &lt;a href=&#34;https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms&#34;&gt;Divide &amp;amp; Conquer&lt;/a&gt;하는 것이 기본이다.&lt;/p&gt;

&lt;p&gt;다행히, 오늘 작업 중에야 RequireJS가 조금 파악이 되어, 조만간 AnguarJS도 비동기 로딩할 수 있을 것 같은 기대가 든다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 19일: RequireJS - 비동기(async) JS 로더</title>
      <link>http://hatemogi.com/holiday-project-day-19/</link>
      <pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-19/</guid>
      <description>

&lt;p&gt;개인 프로젝트 19일째, 오늘은 비동기식 자바스크립트 로더, &lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;에 대해 살펴봤다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/requirejs-logo.png&#34; style=&#34;width: 200px;&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;비동기-모듈-선언-amd:76bc47f87822f82bbf96592482914fb5&#34;&gt;비동기 모듈 선언 (AMD)&lt;/h2&gt;

&lt;p&gt;오늘 고생된 작업의 시작은, 오전에 지금까지 진행한 프로젝트 데모 사이트에서, 크롬 브라우저의 &lt;a href=&#34;https://chrome.google.com/webstore/detail/pagespeed-insights-by-goo/gplegfbjlmmehdoakndmohflojccocli?hl=ko&#34;&gt;PageSpeed&lt;/a&gt;를 돌려본 것이 화근이었다.  웹페이지 로딩 속도에 관련한 각종 검사를 하고 개선할 방안을 추천해주는 &lt;a href=&#34;https://chrome.google.com/webstore/detail/pagespeed-insights-by-goo/gplegfbjlmmehdoakndmohflojccocli?hl=ko&#34;&gt;PageSpeed&lt;/a&gt;가 내게 권장하기를,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;자바스크립트 파일들을 비동기식으로 로딩하시죠~!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라고 하는 게 아닌가?!&lt;/p&gt;

&lt;p&gt;음, 비동기식 로딩이라&amp;hellip; &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그의 가장 마지막에 자바스크립트 파일들을 로딩하면 되는건가? 아니면, &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에 &lt;code&gt;async&lt;/code&gt; 속성을 주면 되는 건가?&lt;/p&gt;

&lt;p&gt;조금 찾아보니, &lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;AMD&lt;/a&gt;라고 비동기 모듈 선언(Asynchronous Module Definition)이라는 주제를 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/AMD_overview.png&#34; alt=&#34;https://en.wikipedia.org/wiki/File:Asynchronous_Module_Definition_overview.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;쉽게 말해서, 여러 JS 파일들을 하나씩 차례로 읽지 말고, 동시다발적으로 읽자는 얘기고, 그러면 당연히 여러 파일을 전부 다 읽는 데 필요한 시간이 줄어들 수 있다는 얘기다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://requirejs.org/docs/whyamd.html&#34;&gt;이걸 왜 써야 하는지 아주 상세한 문서&lt;/a&gt;가 있는데, 상세한 만큼, 내용도 길다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;그냥 HTML 문서에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 넣으면 되는 것을, 이 장문의 영문을 읽고 해석하고 적용해야 하는 걸까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하는 불평이 스멀스멀 올라왔지만, &amp;ldquo;그래 어디 한번 써보기나 합시다&amp;rdquo;는 마음으로 적용해보기로 했다. AMD를 위한 라이브러리가 꽤 여럿 있는 것 같은데, 그중에서도 가장 눈에 띈 &lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;를 써보기로 했다.&lt;/p&gt;

&lt;p&gt;일단 아주 긴 문서 길이에 살짝 위축됐고, AngularJS나 Karma와의 궁합이 잘 안 맞을 수 있으니, 자칫하면 취소하려는 마음으로 브랜치부터 땄다. 지금까지의 &lt;code&gt;master&lt;/code&gt; 브랜치에서 &lt;code&gt;require.js&lt;/code&gt; 브랜치를 땄다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout -b require.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;requirejs-적용-시도:76bc47f87822f82bbf96592482914fb5&#34;&gt;RequireJS 적용 시도&lt;/h2&gt;

&lt;p&gt;문서를 보며 따라 해보니, 기본 개념은 아래 코드가 핵심이었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(&#39;모듈ID&#39;, [&#39;필요한모듈1&#39;, &#39;필요한모듈2&#39;], function(모듈1, 모듈2) {
  // 모듈1, 모듈2를 사용해서 무언가를 하는 코드
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특정 모듈을 &lt;code&gt;define&lt;/code&gt; 이라는 함수로 선언한 수 있고, 그 모듈은 &lt;code&gt;필요한모듈1&lt;/code&gt;과 &lt;code&gt;필요한모듈2&lt;/code&gt;를 필요로 하는 상황이다. 이 모듈을 쓰고자 한다면, RequireJS가 그 모듈들을 로드한 뒤에 이 모듈 선언 함수 부분을 실행한다. 즉, 의존성을 쫓아 로드할 수 있다.&lt;/p&gt;

&lt;p&gt;비동기로 동시다발적으로 로드하고, 의존성이 있는 경우에는, 그 의존하는 모듈이 로드된 다음에 해당 코드를 실행할 수 있으므로, 로드 순서에 따른 문제도 피할 수 있고, 전체 로딩 시간은 짧아지는 효과를 노리는 것이다.&lt;/p&gt;

&lt;p&gt;게다가, 선언만 해놓고, 실제로 쓰지 않는다면, 불필요하게 읽지 않으므로, 웹사이트의 전반적인 속도가 빠르게 느껴질 수도 있다. 예를 들어, 웹사이트 일부에 &lt;code&gt;D3.js&lt;/code&gt;를 쓰는 경우, 의존성 선언을 해놓고, 필요한 부분에서만 디펜던시를 걸어서 사용하면, 꼭 필요한 경우에만 로딩되게 할 수 있다.&lt;/p&gt;

&lt;p&gt;개념이며 목표며, 다 좋은데, 실제로 적용해보려니, Karma와 같이 쓰기가 쉽지 않았다. &lt;a href=&#34;http://karma-runner.github.io/0.8/plus/RequireJS.html&#34;&gt;Karma 사이트에 RequireJS와 함께 쓰는 법을 알려주는 문서&lt;/a&gt;가 있었지만, 아직 이해가 부족해서인지 따라해 봐도 쉽게 해결할 수 없었다.&lt;/p&gt;

&lt;p&gt;한나절 전부를 써서, 결국 간단히 Karma로도 테스트를 수행하고, 웹 브라우저에서도 잘 동작하는 코드를 작성할 수 있었는데, 그래도 아직 뭔가 부족하다. 아직 AngularJS의 컨트롤러 등을 테스트하는 코드를 깔끔하게 작성하지 못한 상태다.&lt;/p&gt;

&lt;p&gt;AngularJS는 별도 의존성이 없으므로,  차라리 그냥 동기 방식으로 미리 로딩하고, 나머지만 RequireJS에 묶는 게 편할지도 모르겠다. 계속 써볼지 말지 아직은 불투명한 상황. 내일이라도 지금 작업하는 브랜치를 그냥 지워버릴지도&amp;hellip; ㅠ.ㅠ&lt;/p&gt;

&lt;p&gt;우선, RequireJS를 적용한 브랜치는 아래 주소에 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/tree/require.js&#34;&gt;https://github.com/hatemogi/holiday-project/tree/require.js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-18&#34;&gt;어제&lt;/a&gt; 알아본 Grunt로 &lt;code&gt;karma&lt;/code&gt; 태스크를 넣어두었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt karma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간신히, 기본적으로 돌아가게는 했으나, 아직 더 자세히 알아보며 써봐야 할 단계다. 이해가 부족하다.&lt;/p&gt;

&lt;h2 id=&#34;새로운-웹-개발-기술들:76bc47f87822f82bbf96592482914fb5&#34;&gt;새로운 웹 개발 기술들&lt;/h2&gt;

&lt;p&gt;무엇 하나 개발하기에도 바쁜 데, 늘 따라가기 힘든 새로운 기술들이 쏟아져 나온다. 하도 많이 나와서, 다 알아보기도 힘들고, 또 대다수는 조금 쓰이다가, 버려지는 것들도 있어서 남들이 많이 쓰기 전까지는 기다리는 것이 현명한 판단일 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만, 그렇다고 늘 하던 대로만 하면, 나아지는 것이 없다.&lt;/p&gt;

&lt;p&gt;나름의 내 정체성은 (아직) 웹 개발자인데, 너무 모르고 지나가는 기술들이 많았었나 보다. 모르는 기술들을 뒤늦게 살펴보고 있으니,  정작 &lt;strong&gt;실제&lt;/strong&gt; 개발작업은 더뎌져서 답답하기도 한데, 그래도 당장 현업의 개발 업무가 눈앞에 있다면, 이렇게 모르는 기술 알아볼 시간도 없이 개발했을텐데, 이번 기회에 여유롭게(?) 이것저것 다양히 알아보고 있으니, 그것참 사치스러운 시간이다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 18일: Grunt - 자바스크립트 작업 실행기</title>
      <link>http://hatemogi.com/holiday-project-day-18/</link>
      <pubDate>Sat, 24 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-18/</guid>
      <description>

&lt;p&gt;개인 프로젝트 18일째, 오늘은 자바스크립트 작업 실행기(task runner), &lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;를 프로젝트에 적용했다. 자동화 테스트를 실행하거나, 자바스크립트 파일들을 합치거나 최소화하는 일처럼 자주 반복하는 프로젝트 수반 작업을 편리하게 실행할 수 있게 해주는 도구다.&lt;/p&gt;

&lt;p&gt;Node 환경에서는, npm만으로도 충분할 수 있는데, &lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;에 몇 가지 마음에 드는 &lt;a href=&#34;https://github.com/gruntjs&#34;&gt;플러그인&lt;/a&gt;이 있어서, 곧바로 적용해 보기로 했다.&lt;/p&gt;

&lt;p&gt;우선 npm으로 간단히 Grunt를 설치한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gruntfile-기본:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Gruntfile 기본&lt;/h2&gt;

&lt;p&gt;Make를 쓸 때 Makefile이나 Rake를 쓸 때 Rakefile이 있듯, Grunt를 위해서는 &lt;code&gt;Gruntfile.js&lt;/code&gt;가 있다. 프로젝트 디렉터리에 있는 이 파일을 기준으로 각종 작업을 실행한다.&lt;/p&gt;

&lt;h3 id=&#34;gruntfile-js-예제:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Gruntfile.js 예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = function(grunt) {
  // 작업을 위한 설정
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
      build: {
        src: &#39;src/app.js&#39;,
        dest: &#39;build/app.min.js&#39;
      }
    }
  });

  // &amp;quot;uglify&amp;quot; 작업을 위한 플러그인 등록
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);

  // 기본 작업에 &#39;uglify&#39; 등록
  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 &lt;code&gt;Gruntfile.js&lt;/code&gt;를 프로젝트 최상위 디렉터리에 두고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 명령을 실행하면, 아무 작업 이름을 주지 않았으므로 &lt;code&gt;default&lt;/code&gt; 작업을 실행하려고 하며, 위 &lt;code&gt;Gruntfile.js&lt;/code&gt;의 최하단에 명시한 대로 &lt;code&gt;uglify&lt;/code&gt; 작업을 진행한다. 그러면, &lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-uglify&#34;&gt;uglify 플러그인&lt;/a&gt;로 등록한 작업을 한다.&lt;/p&gt;

&lt;p&gt;즉, 위 예제의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt uglify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;라고 실행해도 결과는 같다. 참고로 &lt;code&gt;Gruntfile.js&lt;/code&gt; 대신 &lt;code&gt;Gruntfile.coffee&lt;/code&gt; 파일을 준비해 둬도 그 역할은 같으며, 단지 자바스크립트 대신 커피스크립트 문법으로 해석한다.&lt;/p&gt;

&lt;h2 id=&#34;grunt-플러그인-추가:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Grunt 플러그인 추가&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gruntjs&#34;&gt;플러그인&lt;/a&gt;이 꽤 많았고, 그중 아래의 플러그인을 골라 설치했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-coffee&#34;&gt;grunt-contrib-coffee&lt;/a&gt;: 커피스크립트 컴파일&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-uglify&#34;&gt;grunt-contrib-uglify&lt;/a&gt;: Ugilfy로 자바스크립트 파일 최소화&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-watch&#34;&gt;grunt-contrib-watch&lt;/a&gt;: 특정 파일들 감시하다가, 변경되면 지정한 작업 수행&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-jshint&#34;&gt;grunt-contrib-jshint&lt;/a&gt;: JSHint로 자바스크립트 파일 검증&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이하는, 오늘 작성한 &lt;code&gt;Gruntfile.coffee&lt;/code&gt; 파일의 일부다.&lt;/p&gt;

&lt;h3 id=&#34;gruntfile-coffee-https-github-com-hatemogi-holiday-project-blob-day-18-gruntfile-coffee:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-18/Gruntfile.coffee&#34;&gt;Gruntfile.coffee&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports = (grunt) -&amp;gt;
  js_files = [&#39;app.js&#39;, &#39;lib/*.js&#39;, &#39;public/js/app.js&#39;]

  grunt.initConfig {
    # 중간 생략
    watch:  {
      coffee: {
        files: [&amp;quot;public/assets/*.coffee&amp;quot;]
        tasks: [&amp;quot;coffee&amp;quot;, &amp;quot;uglify&amp;quot;]
      }
      jshint: {
        files: js_files
        tasks: [&amp;quot;jshint&amp;quot;]
      }
    }

    jshint: {
      all: js_files
    }
  }
  # 중간 생략
  grunt.registerTask &#39;default&#39;, [&#39;coffee&#39;, &#39;uglify&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본 작업에는 &lt;code&gt;coffee&lt;/code&gt;와 &lt;code&gt;uglify&lt;/code&gt;를 걸어 두었고, 별도로 &lt;code&gt;watch&lt;/code&gt; 작업을 추가해서,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;를 실행해 두고, 커피스크립트 소스파일을 편집하면, 그 후 저장할 때마다, 즉시 커피스크립트 컴파일하며, jshint로도 바로 검사한다. 더 나아가, 셀프 테스팅 코드도 &lt;code&gt;watch&lt;/code&gt;에 걸어두면, 그때그때 테스트 결과도 바로 확인할 수 있겠다.&lt;/p&gt;

&lt;h2 id=&#34;grunt-쓸만한가:3c636ce3d1e45b6e02b2bb52d247e81f&#34;&gt;Grunt, 쓸만한가?&lt;/h2&gt;

&lt;p&gt;npm의 script 섹션을 써도 웬만큼 다 되는데, 굳이 수고를 들여 별도의 작업 실행기가 필요할까? 잠깐 살펴보니, 그래도 될 거 같다. 우선 그 약간의 수고가 크지 않게 잘 만들어져있고, 문서화도 잘 돼 있다. 무엇보다, 플러그인이 많아서, 원하는 기능을 손쉽게 가져다 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;그리고, 참고로, &lt;a href=&#34;http://gruntjs-kr.herokuapp.com/&#34;&gt;Grunt (비공식) 한글 사이트&lt;/a&gt;도 있으니, 한글 문서로도 살펴볼 수 있어서 좋다.&lt;/p&gt;

&lt;p&gt;오늘 작업을 포함해, 지금까지 진행하고 있는 내용을 GitHub에 올려놓고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project&#34;&gt;https://github.com/hatemogi/holiday-project&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;진행하는 내용은, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-17/&#34;&gt;어제 살펴본 Travis CI&lt;/a&gt;로 지속적으로 통합되며, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-14/&#34;&gt;Heroku&lt;/a&gt;에 이하 주소로 자동 스테이징되고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://holiday-project-staging.herokuapp.com&#34;&gt;https://holiday-project-staging.herokuapp.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 17일: Travis CI, 지속적 통합 서비스</title>
      <link>http://hatemogi.com/holiday-project-day-17/</link>
      <pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-17/</guid>
      <description>

&lt;p&gt;개인 프로젝트 17일째, 오늘은 지속적 통합 서비스인 &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;를 살펴보고, 개인 프로젝트에 적용해봤다.&lt;/p&gt;

&lt;h2 id=&#34;travis-ci-소개:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Travis CI 소개&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;는 GitHub과 연동해 &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;지속적 통합(Continuous Integration)&lt;/a&gt;을 호스팅해주는 서비스다.&lt;/p&gt;

&lt;p&gt;지속적 통합의 정확한 의미는 조금 더 넓을 수 있지만, &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;로 한정해서 쉽게 생각하자면, GitHub 저장소에 새로운 커밋이 push되었을 때 CI 서버가 뒤에서 자동으로 새로운 커밋을 가져와서 빌드 테스트를 수행하고, 그 결과를 리포팅 해주는 서비스다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C, C++, Clojure, Erlang, Go, Groovy, Haskell, Java, JavaScript (Node.js), Objective-C, Perl, PHP, Python, Ruby, Scala&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이상의 다양한 언어 환경에서의 빌드 테스트를 대행해주고, 더불어 다양한 데이터스토어와 메시지 브로커 같은 툴들도 미리 설치돼 있어서, 테스트를 위해 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 언어도 비슷하겠지만, Node.js의 경우에도 버전을 명시해서 여러 버전에 대해 동시에 테스트를 맡길 수도 있다. 예를 들어, 0.10.x 버전과 0.8.x 버전 모두에서 테스트하고 결과를 확인하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt; 사이트에 GitHub 계정으로 로그인할 수 있고, 연동된 기능을 통해 로그인한 계정의 저장소 목록을 열람하고, 웹 훅(Web Hook)을 간단히 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;웹 훅이 설정되고 나서 GitHub 저장소에 새로운 커밋이 들어오면, &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;가 바로 알게 되고, 설정에 따라 빌드 테스트를 수행한다. 설정을 위해서는 저장소에 &lt;code&gt;.travis.yml&lt;/code&gt;이라는 YAML 파일을 넣어 두면 된다. Node.js용 설정 파일의 예는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt; language: node_js
 node_js:
   - &amp;quot;0.10&amp;quot;
   - &amp;quot;0.11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 설정한 프로젝트의 경우, 0.10.x대의 최신 버전과, 0.11.x대의 최신 버전으로 빌드 테스트를 진행한다.&lt;/p&gt;

&lt;h2 id=&#34;travis-ci-적용:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Travis CI 적용&lt;/h2&gt;

&lt;p&gt;현재 진행하는 프로젝트의 &lt;a href=&#34;https://github.com/hatemogi/holiday-project/&#34;&gt;GitHub 저장소&lt;/a&gt;에 Travis CI를 적용했다.&lt;/p&gt;

&lt;h3 id=&#34;프로젝트-현재-상태-https-travis-ci-org-hatemogi-holiday-project-builds-25843181:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://travis-ci.org/hatemogi/holiday-project/builds/25843181&#34;&gt;프로젝트 현재 상태&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-current-status.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;간단히 적절한 설정을 한 뒤, 저장소에 &lt;code&gt;git push&lt;/code&gt;를 하고 나면, Travis CI가 테스트를 수행하고, 위와 같은 &lt;a href=&#34;https://travis-ci.org/hatemogi/holiday-project/builds/25843181&#34;&gt;결과 페이지&lt;/a&gt;를 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;빌드-테스트-결과-로그:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;빌드 테스트 결과 로그&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-test-result.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;상세한 빌드 로그도 살펴보고 무엇이 잘되고 잘못됐는지도 자세히 파악할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;github-저장소-readme-https-github-com-hatemogi-holiday-project-readme:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project#readme&#34;&gt;GitHub 저장소 README&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/travis-build-status-img.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;최종 빌드 테스트의 성패에 따른 이미지 링크도 있어서, 저장소의 README파일에 링크를 걸어두면, 위와 같이 성공했을 경우, &lt;code&gt;build passing&lt;/code&gt;이라는 초록 버튼이 보이게 할 수 있다. 그리고, 해당 이미지 링크에 &lt;code&gt;branch&lt;/code&gt; 파라미터를 줘서 특정 Git 브랜치의 최종 커밋에 대한 이미지도 보일 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;heroku에-자동배포:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;Heroku에 자동배포&lt;/h2&gt;

&lt;p&gt;빌드 테스트가 성공하면, 스테이징 서버에 자동으로 배포한다면 어떨까? 좀 더 과감한 접근이 가능한 경우라면, 아예, 빌드 테스트 성공 후에는 실 서비스 서버에 배포하게 하는 것도 가능하겠다. 더구나 지금처럼 가벼운 개인 프로젝트의 경우, 빌드 테스트 성공 후에는 그때그때 바로 배포하면 매우 편리할 것이다. 하지만, 우린 사려깊은 개발자이니, 우선 스테이징 서버에 자동으로 배포해보자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;의 &lt;a href=&#34;http://docs.travis-ci.com/user/deployment/heroku/&#34;&gt;Heroku Deployment&lt;/a&gt;라는 문서에 해당 내용이 친절히 안내돼 있다. 아래처럼 &lt;a href=&#34;https://github.com/travis-ci/travis.rb#readme&#34;&gt;travis CLI&lt;/a&gt;로 설정을 자동으로 추가할 수 있고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;travis setup heroku
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;바뀐 &lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-17/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;의 내용을 보면, travis CLI가 추가한 부분은 아래와 같다.&lt;/p&gt;

&lt;h3 id=&#34;travis-yml:cbcece881c9fc9ad90cee3dceeb8ea69&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-17/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:
  provider: heroku
  api_key:
    secure: bbxlxzhB4AedhkiqKVnagzWVWpe+kusUbeYZhRjL1BJfzvGO0zXktzyqNvy6wANSetDgSMQL/wZsPkIcbtDFU1QzsvXxrfmc33TMFARCQ6JJpb+EHD31HluOwA/8nbtsqQsz8UXW+7jKjtuAxpo0ZzLE7KI0ckQRUKIRQAcky+I=
  app: holiday-project-staging
  on:
    repo: hatemogi/holiday-project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;중간에 &lt;code&gt;api_key&lt;/code&gt; 부분이 Heroku에 배포하기 위한 Heroku API 키를 Travis CI만 해석할 수 있게 암호화한 값이다.&lt;/p&gt;

&lt;p&gt;이렇게 설정을 마치고, GitHub에 새로운 커밋을 push 했더니, 문제없이 빌드 테스트를 마쳤고, Heroku에도 자동으로 배포됐다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-14/&#34;&gt;14일째, 수동으로 Heroku에 배포한&lt;/a&gt; 실 서비스(?) 주소와 오늘부터 Travis CI가 자동 배포하는 스테이징 서버의 주소는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;(실 서비스) &lt;a href=&#34;http://holiday-project.hatemogi.com/&#34;&gt;http://holiday-project.hatemogi.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(스테이징) &lt;a href=&#34;http://holiday-project-staging.herokuapp.com/&#34;&gt;http://holiday-project-staging.herokuapp.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;아직 둘의 차이는 없지만, 개발 과정에서 종종 차이가 있을 것이고, 실 서비스 배포 전에, 로컬 테스트와 더불어 스테이징 테스트까지도 아주 편리하게 할 수 있겠다. 그것참 개발하기 편한 세상이다.&lt;/p&gt;

&lt;p&gt;이로써, 그간 살펴보려고 모아두었던 기술 주제들은 대략적으로나마 알아보았다. 내일부터는, 본격(?) 개발 작업에 들어가려 한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 16일: 중간 점검 - 왜 이 프로젝트를 하나?</title>
      <link>http://hatemogi.com/holiday-project-day-16/</link>
      <pubDate>Thu, 22 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-16/</guid>
      <description>

&lt;p&gt;30일의 휴가 동안 개인적으로 진행하고 있는 프로젝트, 그 절반의 시간이 지났다. 사실 프로젝트라고 말하기는 어려울 수 있는 것이, 딱히 정해진 목표 결과물 없이, 그간 알아보고 싶었던 기술 주제를 공부해보고 있는 성격이 강해서, 정확히 말하면, &amp;ldquo;다양한 웹 개발 기술 셋 훑어보기 프로젝트&amp;rdquo;라고 해야 맞는 건지도 모르겠다.&lt;/p&gt;

&lt;p&gt;지난주에 딸내미 100일 떡을 돌리러 회사에 잠깐 들렀고, 오늘 또 잠시 들렀다. 그러면 지금까지 보름 동안 벌써 두 번 들른 것이다. 고작 며칠 집에서 쉬었는데, 뜻밖에도, 회사에 가고 싶었다. 어젯밤 라디오스타에 출연한 배철수 아저씨가, &amp;ldquo;방송  시간이 아니어도 방송국에서 산다&amp;rdquo;는 얘기를 했는데, 이상하게도 어느 정도 이해가 된다. 사실 나도, 제주에서 아는 사람이라고는 회사 사람들뿐이고, 공통 관심사인 &amp;lsquo;개발 얘기&amp;rsquo;를 할 만한 사람들도 그 사람들뿐이니까.&lt;/p&gt;

&lt;p&gt;어쨌든, 간만에 회사에 갔더니, 몇몇 동료 개발자분들이 내 프로젝트 글을 읽고 있다고 말해주었고, 꽤 완곡하고 정중한 표현으로 몇 말씀 해주셨으나, 냉정하게 해석하면 두 가지 질문이 많았다. (솔직히 말하면 많다기 보다, 딱 세 분이 물어봐 주셨다. ㅎ)&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;그거 뭘 하시려는 건지 모르겠어요.&lt;/li&gt;
&lt;li&gt;왜 하시는 거에요?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;딱히 깊게 생각해 보지 않고 진행한 것이라, &amp;ldquo;그냥요&amp;rdquo;라고 대답하는 것이 가장 정확하겠지만, 즉흥적으로 입에서 튀어나온 답변은 그랬다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;최근 1~2년간 개발을 하지 않다 보니, 개발이 하고 싶었어요.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;장황한-푸념:1fa7e296b3890454874fa1b56be7e1c9&#34;&gt;장황한 푸념&lt;/h2&gt;

&lt;p&gt;개발자에서 개발팀장이 된 지 2년쯤 된 것 같은데, 나를 포함한 (적어도 우리 회사에서 내 주변 대다수의) &lt;strong&gt;개발팀장은 개발을 하지 않는다&lt;/strong&gt;. 내 생각에도 개발팀장의 가장 중요한 역할은 &amp;lsquo;팀원들이 개발을 잘하도록 지원하는 것&amp;rsquo;이지, 자신이 직접 개발하는 것은 아니다. 논란과 이견의 여지가 크지만, 직접 개발하면 오히려 팀원들이 개발을 잘하는 데에 방해된다고 생각한다. 아무래도 팀장의 입김이 지나치게 세게 작용해서 그릇된 결론을 도출하기도 쉽고, 게다가 팀원들이 훨씬 더 개발을 잘하므로, 걸리적거리기만 할 수도 있다.&lt;/p&gt;

&lt;p&gt;그런 생각에서, 난 팀장이 된 뒤, 될 수 있는 대로 개발적인 이슈는 팀원들에게 위임하는 편이다. 내가 하는 일이라고는 번거로운 보고 업무를 한다거나 다른 팀에게 가서 우리 팀 서비스를 영업한다거나, 윗분들께 업무성과를 홍보한다거나, 그런 잡일을 한다. 단적으로 얘기하면, 그전에는 소스코드 에디터나 IDE, 터미널을 사용하는 시간이 많았다면, 팀장이 되고 나서는 이메일 애플리케이션을 가장 많이 쓰게 됐으니까, 얼마나 개발에서 멀어졌는지 더 얘기하지 않아도 될 것 같다.&lt;/p&gt;

&lt;p&gt;한 2년 해보니까, 그래도 팀장 역할도 꽤 잘하는 것 같다. 자동차 운전자의 80%가 본인은 평균 이상의 운전 실력을 갖추고 있다고 착각한다지 않는가? 분명 상식적으로 평균 이상은 50%에 가까워야 하는데, 80%라니&amp;hellip; 무려 30%가 얼토당토않은 착각을 하는 것이지. 아마도 내가 스스로 판단하는 팀장 역할 수행 능력도 그런 착각의 일종이겠지만, 착각은 개인의 자유니까. 이런 착각으로, 아주 많은 뛰어난 개발자들이 그냥 평범한 매니저의 길로 가는 것이 아닐까?&lt;/p&gt;

&lt;p&gt;그러나 문제는, 그 평균 이상은 충분치 않고, 적어도 개발자로 현업에서 일할 때의 수행 능력이, 팀 매니저로서 하는 수행 능력에 비해서 나았을 것 같다. 소위, &amp;ldquo;뛰어난 개발자들 멍청한 매니저로 만든다&amp;rdquo;지 않던가? 난 뛰어나지도 않으니, 얼마나 멍청한 매니저가 되었겠는가?! 그리고 무엇보다 결정적인 문제는, 개발은 잘하고 싶고, 재미도 있는데, 매니징는 잘하는 것 같지도 않고, 또 잘하고 싶지도 않다는 점이다.&lt;/p&gt;

&lt;p&gt;가까운 사람에게 이런 솔직한(?) 푸념을 늘어놓으면, 주변의 훌륭한 사람들은 그렇게 말한다. &amp;ldquo;팀장이라고 개발하지 말라는 법이 있는 건 아니잖아. 그냥 개발도 같이 해.&amp;rdquo; 오우! 그건 리더 역할을 훌륭하게 하고 있을 때 생각해 볼 수 있는 것 아닐까? 당장 매니저 역할도 제대로 못 해서 문제인데, &lt;strong&gt;사치스러운 개발&lt;/strong&gt;이라니?!&lt;/p&gt;

&lt;p&gt;개발팀장의 푸념이 길어졌는데, 그만하고 정리하면, 그렇게 &amp;ldquo;개발 현업에서 멀어지고 나니, 다시 현업이나 기술 이슈에 그리움이 커졌고, 그걸 시간내서 보충하고 싶었다&amp;rdquo;고 이유를 둘러댈 수 있겠다.&lt;/p&gt;

&lt;p&gt;그런 한편, 사실 현업 개발자일 때는, &amp;ldquo;당장 눈앞의 현업이 바빠서 새로운 기술 셋을 살펴볼 여유 시간이 없다&amp;rdquo;고 했으니, &amp;ldquo;팀장이라서 그간 개발 공부를 하지 못했다&amp;rdquo;라는 것 역시 &lt;strong&gt;그럴싸한 핑계일지도 모르겠다.&lt;/strong&gt; 의지만 있다면 할 수 있는 것일지도 모른다.&lt;/p&gt;

&lt;h2 id=&#34;이제야-중간-점검:1fa7e296b3890454874fa1b56be7e1c9&#34;&gt;이제야 중간 점검&lt;/h2&gt;

&lt;p&gt;장황했으나, 결론은,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;그냥 그간 알아보고 싶었던 주제들을 이제야 휴가기간이라는 여유를 틈타 살펴보고 있다.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정도가 될 수 있겠다. 언제 기회가 되면, &amp;ldquo;그런 생각이 있으면서도 왜 팀장직을 맡게 되었는가&amp;rdquo;에 대해서도 블로깅 해보고 싶다. 주변에 보면, 안이하게 막연히 &amp;ldquo;나이가 들어서도 계속 개발자 할래요&amp;rdquo;라는 사람들이 많아서, 어떤 점을 더 고려해야 하는지 따끔하게 알려주고 싶은 훈수 심리가 발동돼서 말이다.&lt;/p&gt;

&lt;p&gt;어쨌건, 보름간을 되돌아 보니, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-01/&#34;&gt;첫날&lt;/a&gt; 언급했던 주요 관심 주제들을 거의 다 살펴본 것 같다. 정말 뜻밖에, 부족하게나마 &amp;ldquo;매일 블로깅 해보자&amp;rdquo;는 목표도 아직은 잘 달성하고 있다. 작심삼일로 끝날 줄 알았거늘, 이런 스스로 대견한 상황이라니! 내일 travis-ci까지만 더 알아보고, 그 뒤로는 뭐라도 만들어 보는 데 주력해 보겠다.&lt;/p&gt;

&lt;p&gt;지난 보름간 가장 큰 소득을 꼽자면, D3.js를 새로이 알게 된 것과, AngularJS를 살펴본 것을 꼽을 수 있겠다. 너무 이른 판단인지 모르겠으나, 지금 jQuery나 트위터 부트스트랩이 아주 널리 쓰이듯이, 조만간 AngularJS도 웹애플리케이션 개발자라면 반드시 알고 써야할 프레임워크가 될 거라고, 감히 주제넘게, 단언한다.&lt;/p&gt;

&lt;p&gt;아, 아니다. 더 큰 소득이 있다. 그동안 자신이 얼마나 (게으르게) 개발에서 멀어져 있었고, 세상은 얼마나 더 빠르게 더 좋은 기술들이 나오고 있는지를 되새기게 된 소득이 가장 크겠다.&lt;/p&gt;

&lt;p&gt;이상, 중간 점검 끝~!&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 15일: AngularJS 코드스쿨 강좌 소개</title>
      <link>http://hatemogi.com/holiday-project-day-15/</link>
      <pubDate>Wed, 21 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-15/</guid>
      <description>&lt;p&gt;프로젝트 15일째, 오늘은 드디어 &lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;를 살펴봤다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;는 구글에서 만든 웹앱 개발을 돕는 자바스크립트 프레임워크로, 복잡한 웹애플리케이션을 만들기 쉽도록 도와준다. 호평을 들어온 터라 나도 언제 한번 써봐야지 생각했었는데, 때마침 &lt;a href=&#34;codeschool.com&#34;&gt;Code School&lt;/a&gt;에 &lt;a href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34;&gt;Angular 강의&lt;/a&gt;가 새로 올라와서 아주 편리하게 기초를 배워볼 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34;&gt;Shaping up with Angular.js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그전에는 &lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS 공식사이트&lt;/a&gt;의 튜토리얼을 조금 따라 해보다가 말았는데, 이번에는 훨씬 쉽게 기본 개념을 익혀볼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/angular-badge.png&#34; style=&#34;width: 300px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;잠깐 다른 얘기로, 영어권 개발자에게는 이런 학습 자료와 잘 정리된 온라인 강의 사이트가 유용할 것 같아 참 부럽다. 한국어 자료로도 잘 되어 있으면 참 좋겠다. 참고로, 국내에는 이고잉님의 &lt;a href=&#34;http://opentutorials.org/&#34;&gt;생활코딩&lt;/a&gt;을 비롯해 매우 훌륭한 정리가 이미 많지만, 더 다양하고 활발한 정리와 공유가 이뤄지면 좋겠다.&lt;/p&gt;

&lt;p&gt;다시 돌아와서, 아무튼, AngularJS를 써봐야겠다는 생각이 확고해졌다. 새로운 기술이나 도구를 만나면, 그게 유용할지 아닐지를 따지기도 해야겠지만, 그전에 우선 그 대상에 대한 호감이 들고나서야 하는 건데, 그런 관점에서는 일단 호감 단계는 넘어섰고, 앞으로의 웹개발에 꽤 유용하게 사용할 수 있겠다는 기대가 든다.&lt;/p&gt;

&lt;p&gt;그리고 한가지 기대 밖의 소득으로, 강의 마지막에 소개받은 앱이 있는데, 아주 마음에 들어서 바로 구매했다. &lt;a href=&#34;http://kapeli.com/dash&#34;&gt;Dash&lt;/a&gt;라는 앱인데, 각종 개발 문서들을 로컬에 받아서 오프라인 상태에서도 검색해가며 살펴볼 수 있는 맥 앱이다. 브라우저에서 북마크 찾아가며 각종 API 문서 뒤적이는 게 불편한 적이 많았는데, 이 앱 덕에 꽤 편리해질 듯하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/dash.png&#34;  style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;오늘은 강의만 듣고, 별다른 진행이나 정리를 하지 못했다.&lt;/p&gt;

&lt;p&gt;뭔가 찜찜하지만, 밤이 깊었으니, 오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 14일: Heroku에 Node.js 애플리케이션 배포</title>
      <link>http://hatemogi.com/holiday-project-day-14/</link>
      <pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-14/</guid>
      <description>

&lt;p&gt;프로젝트 14일째, 오늘은 데모 웹사이트를 만들어 올리기 위해, (1) 노드용 템플릿 엔진인 &lt;a href=&#34;http://jade-lang.com/&#34;&gt;Jade&lt;/a&gt;를 잠깐 써보고, (2) Heroku에 지금까지 만들고 있는 &lt;a href=&#34;https://github.com/hatemogi/holiday-project&#34;&gt;express 웹앱&lt;/a&gt;을 배포해봤다.&lt;/p&gt;

&lt;h2 id=&#34;node-js-템플릿-엔진-jade:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;Node.js 템플릿 엔진 - Jade&lt;/h2&gt;

&lt;p&gt;루비 쪽의 &lt;a href=&#34;http://haml.info/&#34;&gt;Haml&lt;/a&gt;과 같은 템플릿 엔진이다. 간결한 문법과 들여쓰기로, HTML/XML 태그를 여닫는 번거로움 없이 간편하게 결과 페이지를 만들 수 있다. 이하는 오늘 작성한 템플릿 레이아웃의 일부다.&lt;/p&gt;

&lt;h3 id=&#34;layout-jade-https-github-com-hatemogi-holiday-project-blob-day-14-views-layout-jade-의-일부:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/holiday-project/blob/day-14/views/layout.jade&#34;&gt;layout.jade&lt;/a&gt;의 일부&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;doctype html
html
  head(prefix=&amp;quot;og: http://ogp.me/ns#&amp;quot;)
    meta(charset=&amp;quot;utf-8&amp;quot;)
    meta(name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;)
    title= title
    link(rel=&#39;stylesheet&#39; href=&#39;http://hatemogi.com/bower_components/bootstrap/dist/css/bootstrap.min.css&#39;)
    script(src=&#39;/bower_components/jquery/dist/jquery.min.js&#39;)
    script(src=&#39;/bower_components/bootstrap/dist/js/bootstrap.min.js&#39;)
  body
    block content
    include ga
    include github_badge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 모습인데, HTML 문서의 태그를 들여쓰기로 어느 부분까지 감싸는 것인지 표현한다. 각종 태그를 그대로 쓰면 되고, 괄호 안의 속성값이 그대로 해당 element의 속성이 된다. 중간중간 현재 문맥에 바인딩 된 값을 가져다 쓸 수 있다. 위 레이아웃에서는 &lt;code&gt;title&lt;/code&gt; 태그의 값이 그렇게 사용된다.&lt;/p&gt;

&lt;p&gt;body 태그 바로 아래에 &lt;code&gt;block content&lt;/code&gt; 부분이 실제 본문 내용이 대치/입력돼 최종 출력된다고 보면 된다. &lt;code&gt;include&lt;/code&gt;는 말 그대로 별도 템플릿을 읽는다.&lt;/p&gt;

&lt;p&gt;템플릿 엔진이야 워낙 다양하고, 어떤 언어와 웹서비스 프레임워크를 쓰느냐 만큼 개인별 호불호가 달라서, 스스로 마음에 드는 템플릿 엔진을 골라서 사용하면 된다.&lt;/p&gt;

&lt;h2 id=&#34;heroku에-배포:f1c5f909337c73dfa7f624663e8d9a59&#34;&gt;Heroku에 배포&lt;/h2&gt;

&lt;p&gt;프로젝트가 잘 진행되어, 웹 애플리케이션을 올려서 공개한다면, 아마도 &lt;a href=&#34;http://aws.amazon.com/ko/ec2/&#34;&gt;AWS EC2&lt;/a&gt;나 &lt;a href=&#34;https://cloud.google.com/products/compute-engine/&#34;&gt;Google Compute Engine&lt;/a&gt;에 직접 구축해서 올릴 테지만, 아직 그런 단계는 아니고, 이 블로그를 읽고 있는 소수의 지인께만 보여드리는 데모 웹페이지가 필요한 정도다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://heroku.com/&#34;&gt;Heroku&lt;/a&gt;는 각종 웹 애플리케이션을 올려서 서비스할 수 있는 클라우드 서비스인데, 스타트업들이 즐겨 사용하는 플랫폼이다. 개인적으로는 &lt;a href=&#34;http://hatemogi.com/saas_class/&#34;&gt;2012년에 Coursera에서 SaaS 수업&lt;/a&gt;을 들으며 써본 적이 있는데, 좋은 인상을 받았던 서비스다.&lt;/p&gt;

&lt;p&gt;로컬에서 잘 개발하고, heroku에 생성한 앱의 git 저장소 주소로 push하면 해당 애플리케이션이 배포되며, 곧바로 &lt;code&gt;앱이름.herokuapp.com&lt;/code&gt;에서 접근해 확인할 수 있다. 직접 서버를 설치하고 구동하고 관리할 필요없이 &lt;code&gt;git push heroku&lt;/code&gt;만으로 배포되고, 그 후 운영은 heroku가 알아서 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/heroku-dashboard.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;이번 데모를 위해서 최소 자원을 받았고, 개발용 Postgres 인스턴스도 add-on으로 붙인 화면이다. 비록 1만 레코드까지만 쓸 수 있는, 정말 개발시연용이지만, 지금의 목표에는 충분히 활용할 수 있다. 무엇보다도, 데모를 위한 규모에서는 &lt;strong&gt;무료로 서비스를 이용&lt;/strong&gt;할 수 있다. 보이는가? 월 예상비용 $0.00 !!!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/hatemogi/status/399814963360849920&#34;&gt;개인적으로는 프로젝트 초기에는 그냥 간단히 가볍게 SQLite 활용하자는 마인드&lt;/a&gt;지만, Heroku 특성상, 일단 무료 Postgres를 써보기로 한다.&lt;/p&gt;

&lt;p&gt;배포 중에 발생한 한가지 문제는, &lt;a href=&#34;http://hatemogi.com/holiday-project-day-04/&#34;&gt;프로젝트 4일 차에 알아본 Bower&lt;/a&gt;로 가져다 쓴 Bootstrap과 jQuery를 Heroku에 배포한 앱에서는 설치되지 않았던 점이 있다. 프로젝트 배포하고 &lt;code&gt;bower install&lt;/code&gt;을 실행해야 하는데, Heroku에서 기본으로 그 커맨드를 실행할 이유는 없는 것. 검색을 좀 해보니, 무슨 Heroku의 빌드팩이라는 걸 만들어서 해결하는 방법이 있던데, 뭘 그렇게까지 해야 하나 싶어서 좀 더 검색해보니, &lt;a href=&#34;http://xseignard.github.io/2013/02/18/use-bower-with-heroku/&#34;&gt;아주 간단하게 해결한 방법&lt;/a&gt;을 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;의 &lt;code&gt;scripts&lt;/code&gt; 부분에 &lt;code&gt;postinstall&lt;/code&gt;이라는 항목에, 실행할 스크립트를 넣어 놓으면 &lt;code&gt;npm install&lt;/code&gt;이 진행되고 나서 이 스크립트를 실행하게 되는데, 이 부분을 이용하는 것.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node ./bin/www&amp;quot;,
    &amp;quot;karma&amp;quot;: &amp;quot;./node_modules/karma/bin/karma start&amp;quot;,
    &amp;quot;spec&amp;quot;: &amp;quot;./node_modules/jasmine-node/bin/jasmine-node --coffee --verbose spec&amp;quot;,
    &amp;quot;postinstall&amp;quot;: &amp;quot;./node_modules/bower/bin/bower install&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 간단하게 웹서비스 실행 전에 &lt;code&gt;bower install&lt;/code&gt;을 실행할 수 있다. 한 가지 단점은, 이 커맨드를 실행하기 위해, (실제 실행 때에는 필요하지 않은) bower 의존성을 걸어야 한다는 점이 있으나, 무시할만하다.&lt;/p&gt;

&lt;p&gt;그렇게 해서, 결국 데모 앱을 준비했다. 아직 뭐 하는 기능은 없고, 단지 Heroku에 &lt;strong&gt;텅 빈&lt;/strong&gt; express 앱을 띄워 놓은 것. 차차 여기에 살을 붙이기로 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://holiday-project.hatemogi.com/&#34;&gt;http://holiday-project.hatemogi.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(위 주소에 heroku 서비스를 올려놓았으나, 아직은 방문하지 말아달라. ^^;)&lt;/p&gt;

&lt;p&gt;한가지 전혀 다른 얘기로, Heroku add-on을 살펴보다가 Redis addon을 슬쩍 봤는데, 아래 캡처이미지에 보이듯, 3만8천 개 인스턴스를 서비스하고 있단다. 회사 업무로 우리 팀이 하는 일 중 하나가, 사내에 Redis 인스턴스 클라우드스럽게(?) 제공해주고 운영하는 일인데, 이거 외부에서 장사해도 될만한 일이었구나하는 뒤늦은 아쉬움이 든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/redis-to-go.png&#34; style=&#34;width: 600px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;3만8천 개라니&amp;hellip; 대단하다. 장사 잘되는구나?!&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 13일: 컨테이너 기반 가상화 프레임워크 - Docker</title>
      <link>http://hatemogi.com/holiday-project-day-13/</link>
      <pubDate>Mon, 19 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-13/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-12/&#34;&gt;어제&lt;/a&gt;는 그래프 그리기의 벽을 만났다. 그래프를 본격적으로 공부하자니, 목표로 한 30일 내에는 결과가 나올 것 같지 않다. 한가지 소득이 있다면, 새로 공부할 거리를 장전했다는 것. 이번 휴가가 끝나도 틈틈이 공부할 주제다.&lt;/p&gt;

&lt;p&gt;혹시나 &lt;a href=&#34;https://www.coursera.org/&#34;&gt;Coursera&lt;/a&gt;에 관련 수업이 있지는 않나 해서 찾아봤는데, 8월과 10월에 그래프 그리는 것과 연관이 있어 보이는 수업이 있어서 바로 등록했다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;8월, &lt;a href=&#34;https://www.coursera.org/course/interactivegraphics&#34;&gt;Interactive Computer Graphics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;10월, &lt;a href=&#34;https://www.coursera.org/course/sna&#34;&gt;Social Network Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떤 주제에 대해 처음으로 알아볼 때 가장 어려운 점은 &lt;strong&gt;어디서 무엇부터 공부하는지를 파악하는 것&lt;/strong&gt;이 아닐까? 무엇을 모르는 것인지조차 잘 모르는 상태다. 다행인 것은, 꼬인 끈이라도 하나 잡고 파고들다 보면 조금씩 시야가 드러난다. 그러길 바란다.&lt;/p&gt;

&lt;p&gt;꼭 해야 하는 (업무) 프로젝트인 경우에는, 벽을 만나도 어떻게든 추진해야겠지만, 개인 (취미) 프로젝트인 경우 이런 벽을 만났다고 해서 느슨하게 뒤로 미룬다고 하면 바로 중단되기 쉽다. 안 그래도 의지가 부족한데, 좋은 핑곗거리가 생기는 것이다.&lt;/p&gt;

&lt;h2 id=&#34;docker-알아보기:8eb2dbfb3851cb94638fccef048a1094&#34;&gt;Docker 알아보기&lt;/h2&gt;

&lt;p&gt;그래프 그리기와는 전혀 다른 주제로, 오늘은 &lt;a href=&#34;https://www.docker.io/&#34;&gt;Docker&lt;/a&gt;를 설치해봤다. (이럴 때일수록 뭐라도 일단  진행해야 한다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.docker.io/&#34;&gt;Docker&lt;/a&gt;는 사실 이번 프로젝트가 아주 성공적으로 진행될 경우 필요한 컴포넌트다. 다시 말해, 당장은 필요없는 컴포넌트일 수 있는데, 예전부터 한번 시간이 되면 알아보고 싶었던 프레임워크다. 지금이 그런 &amp;ldquo;시간&amp;rdquo; 아닐까?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker is a container based virtualization framework. Unlike traditional virtualization Docker is fast, lightweight and easy to use. Docker allows you to create containers holding all the dependencies for an application. Each container is kept isolated from any other, and nothing gets shared.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 괜찮아 보이는 설명을 발췌했다. Docker는 가상화 프레임워크인데, 컨테이너 기반 가상화를 사용한다. 일반적인 가상화 방식은 호스트 OS와 게스트 OS가 따로 있고, 게스트 OS부터 분리해 독립된 운영환경을 제공하지만, Docker는 이와 달리, 컨테이너 기반 가상화는 호스트 OS를 그대로 공유하고, 유저 스페이스에서 가상화를 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/holiday-project/docker_vm.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그림: 일반적인 가상화와 컨테이너 비교 (&lt;a href=&#34;https://www.docker.io/the_whole_story/&#34;&gt;https://www.docker.io/the_whole_story/&lt;/a&gt;에서 가져온 이미지)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;나 &lt;a href=&#34;https://en.wikipedia.org/wiki/FreeBSD_jail&#34;&gt;BSD Jail&lt;/a&gt;을 안다면 더 설명이 필요없는 내용이다. (실제로도 &lt;a href=&#34;https://www.docker.io/&#34;&gt;Docker&lt;/a&gt;는 &lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;를 이용한다.)&lt;/p&gt;

&lt;p&gt;뭐가 좋을까? 일반적인 가상화에서 그렇듯, 각각의 애플리케이션이 완전히 독립된(dedicated) 영역에서 CPU, 네트워크, 디스크 자원을 활용할 수 있지만, 그보다 훨씬 가볍다. 마치, 그냥 리눅스 서버에 프로세스 여러 개를 띄운 것 같이 가벼운데, 그 애플리케이션 간의 간섭이 없는 것이다. 다른 점은, 호스트 OS와 같은 OS 환경만을 제공한다는 것이다. 이 때문에 가볍다는 장점이 되는 것이기도 하다.&lt;/p&gt;

&lt;p&gt;또 하나 언급할 만한 점은, 이미 (일반적인) 가상화 장비를 받은 상황에서, 다시 &lt;a href=&#34;https://www.docker.io/&#34;&gt;Docker&lt;/a&gt;를 이용해서 또 자원을 격리 배분할 수 있다. &lt;a href=&#34;http://aws.amazon.com/ko/ec2/&#34;&gt;AWS EC2&lt;/a&gt;나 &lt;a href=&#34;https://cloud.google.com/products/compute-engine/&#34;&gt;Google Compute Engine&lt;/a&gt;에서 리눅스 VM 한 개 받아서, 그 안에 다시 Docker를 이용, 또다시 여러 개의 가상환경을 쪼개서 만들 수 있다. 그 컨테이너들을 내 애플리케이션들이 다 사용하든, 아니면 내 서비스를 사용하는 사용자에게 하나씩 나눠서 제공하든 그것은 자유다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker containers can encapsulate any payload, and will run consistently on and between virtually any server. The same container that a developer builds and tests on a laptop will run at scale, in production, on VMs, bare-metal servers, OpenStack clusters, public instances, or combinations of the above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또 다른 Docker의 특징 중 하나는, 클라우드 환경이든 내 로컬환경이든, 준비해둔 그 가벼운 &lt;code&gt;컨테이너&lt;/code&gt;를 어디서나 실행할 수 있다는 점이다. 개발할 때 쓰는 맥북 프로에 Docker 컨테이너를 준비해두고, 그 컨테이너를 그대로 퍼블릭 클라우드에 올려서 서비스할 수도 있다는 얘기다.&lt;/p&gt;

&lt;p&gt;오늘 Docker에 대해서 알아보기 전에는, 로컬 &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;에 우분투 깔고, 그 안에서 docker를 설치하고 무언가 연습을 해볼 것이라 예상했다. 한번 쭉 해보고 &lt;a href=&#34;http://www.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt;로 개발/테스트 환경을 구축하게 정리할 생각을 했다. 그런데, 조금 더 알아보니 그럴 필요가 없는 것 같다. Docker가 그 관련한 모든 일을 너무 편하게 다 처리해준다. 내가 개발/테스트 환경을 위해 할 일은 훨씬 적을 것 같다.&lt;/p&gt;

&lt;h2 id=&#34;docker-설치해보기:8eb2dbfb3851cb94638fccef048a1094&#34;&gt;Docker 설치해보기&lt;/h2&gt;

&lt;p&gt;우선 한번 따라 해 설치해봤다. 실제 직접 설치해보려거든 이하 내용은 참고만 하고, 원래 사이트의 문서를 읽고 진행하자. 이런 내용은 버전에 따라 쉽게 바뀌고, 이런 블로그 글은 쉽게 쓸모없어지니까 말이다. &lt;a href=&#34;http://docs.docker.io/installation/mac/&#34;&gt;Installing Docker on Mac OS X&lt;/a&gt;라고, 친절하게 Mac OS X에 설치하는 방법이 따로 잘 정리돼 있다. (다른 운영체제나 퍼블릭 클라우드 환경에 설치하는 방법도 아주 잘 나와 있다.)&lt;/p&gt;

&lt;p&gt;심지어 그 설치 과정도 &lt;a href=&#34;http://brew.sh/index_ko.html&#34;&gt;Homebrew&lt;/a&gt;로 몇 단계 만에 끝난다. 로컬에 &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;와 &lt;a href=&#34;http://brew.sh/index_ko.html&#34;&gt;Homebrew&lt;/a&gt;가 설치된 상황에서 입력한 커맨드는 아래가 전부다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install boot2docker
brew install docker
boot2docker init
boot2docker up

boot2docker ssh
# User: docker
# Pwd:  tcuser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막 커맨드로, Docker가 만든 기본적인 리눅스 박스에 ssh접근할 수 있다. 그 리눅스 박스에서 아래의 커맨드를 실행해봤다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker info
sudo docker pull ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 박스에서부터 우분투 환경을 준비하든 CentOS를 준비하든, 각종 컨테이너를 만들어서 실행하고 관리할 수 있는 것. 좀 더 활용해보고,  &amp;ldquo;&lt;a href=&#34;http://docs.docker.io/installation/amazon/#amazon-quickstart&#34;&gt;Amazon EC2에 Docker 설치하기&lt;/a&gt;&amp;rdquo; 같은 문서를 읽어보며 퍼블릭 클라우드에 올려보면 되겠다.&lt;/p&gt;

&lt;p&gt;문서 곳곳에 &amp;ldquo;Docker를 비록 아직 프로덕션 레벨로는 쓰지 말라&amp;rdquo;는 경고가 번듯이 적혀있지만, &lt;a href=&#34;http://blog.docker.io/2014/05/docker-0-11-release-candidate-for-1-0/&#34;&gt;곧 1.0 배포를 앞둔 단계&lt;/a&gt;고, 약간의 모험을 감당할 수 있는 수준이라면 문제없이 써볼 수 있겠다. 지금 내 개발 프로젝트 같은 경우 걱정 없이 쓸 수 있는 상황이다.&lt;/p&gt;

&lt;p&gt;1~2년 전에 LXC를 직접 써서, 컨테이너 가상화를 해보려고 했는데, 네트워크 설정도 어렵고, 디스크 일일이 마운트 하기도 복잡하게 느껴져서, 결국 다음 기회로 미뤘던 기억이 있다. 그 작업의 기억에 비하면, &lt;a href=&#34;https://www.docker.io/&#34;&gt;Docker&lt;/a&gt;가 제공해주는 편리함은 &lt;strong&gt;신세계&lt;/strong&gt;다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트가 아니더라도, 유용하게 활용한 만한 일이 많을 것이라 예상한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 12일: 그래프 그리기 도전 #2</title>
      <link>http://hatemogi.com/holiday-project-day-12</link>
      <pubDate>Sun, 18 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-12</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-11/&#34;&gt;어제&lt;/a&gt; D3.js의 &lt;a href=&#34;https://github.com/mbostock/d3/wiki/Force-Layout&#34;&gt;Force Layout&lt;/a&gt;을 써서, Git 커밋 그래프를 그려봤다. 아무 생각 없이, 전체 커밋을 넣어서 실행해 봤더니, 마구 엉킨 그래프가 보였다. 오늘은 이 그래프의 모양을 어떻게 조금 아름답게 꾸밀 수 있을까를 고민했다.&lt;/p&gt;

&lt;p&gt;우선, 이제 와 고백하건대, 그래프에 대해 잘 모르겠다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;그래프? 그거 노드와 엣지가 있는 자료구조 아니던가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 정도가 내가 알고 있는 수준 전부이다. Git의 커밋 그래프는 일종의 &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_acyclic_graph&#34;&gt;DAG&lt;/a&gt;인데, Directed-Acyclic-Graph의 약자이며, 방향이 있는 그래프인데, 방향의 순환참조가 없는 그래프를 말한다. Git의 내부 구조는 이 DAG가 핵심이다. &lt;a href=&#34;http://eagain.net/articles/git-for-computer-scientists/&#34;&gt;컴퓨터과학자를 위한 Git&lt;/a&gt;이라는 문서에 아주 친절히 설명이 돼 있다.&lt;/p&gt;

&lt;p&gt;그래프도 모르는데, DAG는 어찌 안담? 오래전 학창시절에, 알고리즘 시간에 그래프 순회 알고리즘을 배운 것도 같은데, 이런 그래프도 배웠던가? 혹시나 싶어서, 먼지 폴폴 쌓여있는 학창시절의 알고리즘 교과서를 뒤져봤다. 최단 거리를 찾는 다익스트라 알고리즘을 설명하는 부분에 그래프 순회가 나오기는 했으나, DAG라고 자세히 나오지는 않았다. 휴, 그나마 다행이긴 하나, 만약 배웠다 하더라도, 내가 기억하고 있으리라는 보장은 없다. 그 다익스트라 알고리즘도 지금 짜보라면, 당황할 것이 뻔하지 않은가?!&lt;/p&gt;

&lt;p&gt;이번 프로젝트를 진행하면서 느끼는 것 중 하나는, &amp;ldquo;내가 일하면서 컴퓨터 과학에 관해 이론적으로 공부해 볼 만한 일은 별로 없었다&amp;rdquo;는 것이었다. 나름 오랫동안 인터넷 포털에서 개발자로 근무하며 한 일이라고는, 대규모 사용자가 웹서비스 접근해오면 어떻게 대응해야 하는지 트래픽 대응, 분산처리, 캐시 처리 잘하기, DB에 넣고 빼고 읽은 거 웹에 뿌리는 일처럼 매번 하는 일들을 매년 반복해 왔던 것 같다.&lt;/p&gt;

&lt;p&gt;그냥 환경이 계속 바뀔 뿐이다. 웹이 AJAX낀 웹이 되고, 스트럿츠로 개발하다가 스프링으로 개발하고, 그러다가 레일스로 하고, 아니면 아이폰 개발하고, 뭔가 개발하는 도구나 플랫폼이 바뀔 뿐, 새로운 이론을 배운다거나 과거에 배운 것이라도 활용해 보는 일은 별로 없는 것이다. 경력 &amp;ldquo;기간&amp;rdquo;은 쌓이는데, 진짜 경력이 쌓이는 것인지는 알 수 없다. 알고리즘이랍시고 적용해 본 것은, 캘린더 서비스 개발할 때, 일정 그래프가 겹치지 않도록 배치하는 것 정도가 다였다. 나머지는 뭐 맨&amp;hellip;&lt;/p&gt;

&lt;p&gt;지질한 푸념은 여기까지로 줄이고, 그럼 이제 어떻게 할 것인가? 이제부터라도 공부하면 되는 것 아닌가? 그래프 드로잉이 지금의 주요 관심사니, 관련 책을 찾아봤다. &amp;ldquo;Graph Drawing: Algorithms for the Visualization of Graphs&amp;rdquo;라는 책이 눈에 띄었는데, 가격이 너무 부담된다. 아쉬운 대로, 온라인 책을 찾았다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://cs.brown.edu/~rt/gdhandbook/&#34;&gt;Handbook of Graph Drawing and Visualization&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 챕터를 PDF 파일로 내려받아 볼 수 있다. 그래, 위키피디아랑 온라인 문서들부터라도 틈틈히 읽도록 하자. 문제는 이 그래프 드로잉이라는 주제에 깊이 빠져들면, 30일은커녕 3개월이 되더라도 별다른 결과가 나오지는 않을 것 같다는 것. 아아~&lt;/p&gt;

&lt;p&gt;그래프에 대해 공부도 해야겠지만, 프로젝트 진행을 위해 모르면 모르는 대로 진행은 해봐야겠다 싶어서, 단순 무식하게 생각해 낸 아이디어는,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Force Layout을 이용하되, 중력 기준점을 왼쪽에 두고, 오른쪽에 고정좌표로 최종 헤드의 커밋을 두면 나름 일직선으로 그럴싸하게 보이지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 생각을 바탕으로 어제의 그래프를 다시 그려봤다. 일단, 커밋을 최종 30개만 가져다가, 그린 그래프는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;style&gt;
  circle {
    stroke: black;
    stroke-width: 1.5px;
    fill: steelblue;
    cursor: pointer;
  }
  circle.center {
    stroke: red;
    stroke-width: 1px;
    fill: black;
  }
  line {
    stroke: darkgrey;
    stroke-width: 1.5px;
  }
  text {
    fill: white;
    text-anchor: middle;
    cursor: pointer;
  }
  path {
    stroke: darkgrey;
    stroke-width: 2px;
    fill: none;
  }
&lt;/style&gt;&lt;/p&gt;

&lt;div class=&#34;graph-section&#34;&gt;
  &lt;h3&gt;어떤 Git 저장소의 master 브랜치에 있는 최근 커밋 30개&lt;/h3&gt;
  &lt;svg class=&#34;d3&#34;&gt;&lt;/svg&gt;
  &lt;div class=&#34;panel panel-info&#34;&gt;
    &lt;div class=&#34;panel-heading&#34;&gt;
      원을 클릭해 보세요.
    &lt;/div&gt;
    &lt;div class=&#34;panel-body&#34;&gt;
      커밋메시지가 보일 거에요.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;이론적 바탕없이 무작정 달려든 데에 대한 당연한 결과겠지만, 역시 실패. 방향은 대충 원하는 그림으로 나왔으나, 너무 고정 좌표 쪽으로 노드들이 당겨진 나머지, 위나 아래에 그려졌어야 하는 마지막에서 두 번째 노드가 일직선 상에 위치해버렸다. (맨 오른쪽에서 두 번째 노드를 살짝 드래그해보면 무슨 얘긴지 안다.)&lt;/p&gt;

&lt;p&gt;이쯤에서 그만 다시 graphviz에게 모든 걸 맡겨볼까? 내일은 이 난국을 어떻게 헤쳐나갈지부터 다시 고민해야겠다.&lt;/p&gt;

&lt;p&gt;오늘은 (씁쓸한 마음으로) 여기까지.&lt;/p&gt;

&lt;script&gt;
(function() {
  var chart, circle_click, force, gravity_x, h, links, margin_x, nodes, w, x, y;

  nodes = [];

  links = [];

  w = 700;

  h = 200;

  chart = d3.select(&#34;svg.d3&#34;).attr(&#34;width&#34;, w).attr(&#34;height&#34;, h);

  force = d3.layout.force().distance(1).charge(-50).chargeDistance(30).nodes(nodes).links(links).size([w, h]);

  circle_click = function() {
    var a, data;
    data = d3.select(this).datum();
    a = &#34;&lt;a href=&#39;https://github.com/nodegit/nodegit/commit/\#{data.sha}&#39;&gt;GitHub 링크: \#{data.sha.substr(0, 8)}&lt;/a&gt;&#34;;
    $(&#39;.panel-heading&#39;).html(a);
    $(&#39;.panel-body&#39;).text(data.message);
    return console.log(data);
  };

  margin_x = 50;

  gravity_x = w / 2;

  x = function(x) {
    return x - w / 2 + margin_x;
  };

  y = function(y) {
    return y;
  };

  d3.json(&#39;/js/holiday-project/day-11.json&#39;, function(r, json) {
    var link, node;
    json[&#39;branches&#39;].master.slice(0, 30).forEach(function(c, i) {
      nodes[i] = json.commits[c];
      return nodes[i].index = i;
    });
    nodes.forEach(function(c, i) {
      return c.parents.forEach(function(p) {
        if (nodes[json.commits[p].index]) {
          return links.push({
            source: c.index,
            target: json.commits[p].index
          });
        }
      });
    });
    link = chart.selectAll(&#34;line&#34;).data(links).enter().append(&#34;line&#34;);
    node = chart.selectAll(&#34;circle&#34;).data(nodes).enter().append(&#34;circle&#34;).attr(&#34;r&#34;, function(d) {
      return Math.min(d.change_level, 10);
    }).call(force.drag).on(&#34;click&#34;, circle_click);
    force.on(&#34;tick&#34;, function() {
      nodes[0].x = w * 1.4 - margin_x;
      nodes[0].y = h / 2;
      nodes[0].fixed = true;
      link.attr(&#34;x1&#34;, function(d) {
        return x(d.source.x);
      }).attr(&#34;y1&#34;, function(d) {
        return y(d.source.y);
      }).attr(&#34;x2&#34;, function(d) {
        return x(d.target.x);
      }).attr(&#34;y2&#34;, function(d) {
        return y(d.target.y);
      });
      return node.attr(&#34;cx&#34;, function(d) {
        return x(d.x);
      }).attr(&#34;cy&#34;, function(d) {
        return y(d.y);
      });
    });
    return force.start();
  });

}).call(this);
&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 11일: Git 커밋 그래프 그리기 도전</title>
      <link>http://hatemogi.com/holiday-project-day-11</link>
      <pubDate>Sat, 17 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-11</guid>
      <description>

&lt;p&gt;나는 30일 동안 휴가 중이다. 휴가 동안 개인 개발 프로젝트를 진행하고 있다.&lt;/p&gt;

&lt;h3 id=&#34;d3-js-의-layout-기능:204468a805dd79c7901a2a61584e3071&#34;&gt;&lt;a href=&#34;http://d3js.org&#34;&gt;D3.js&lt;/a&gt;의 Layout 기능&lt;/h3&gt;

&lt;p&gt;오늘 새벽 5시쯤 일찍 잠에서 깼는데 다시 잠이 오지 않아, 침대에 누운 채로 &lt;a href=&#34;http://d3js.org&#34;&gt;D3.js&lt;/a&gt; 문서를 좀 읽었다. &lt;a href=&#34;https://github.com/mbostock/d3/wiki/Force-Layout&#34;&gt;Force Layout&lt;/a&gt; 부분을 보아하니, 원래 계획하던 그래프를 그리는 데에 사용할 수 있을 것 같은 느낌이 왔다. 문서를 마저 읽고, 설레는 마음을 품고, 책상에 앉아서 코딩을 시작했고, 잠깐의 몰입 후에 기본 코드가 완성됐다. 개발이 즐거운 이유는, 몰입(flow)의 경험이 가장 크지 않나 싶다. 피드백을 곧바로 확인할 수 있고, 적절히 도전적인 과제가 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;오, 좋았어! 이 코드를 사용해서 오늘 멋진 그래프를 그릴 수 있을 것 같아!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기대감과 설렘을 담아둔 채, 다른 (놀이) 일정을 위해 집을 나섰다. 기대감 덕분에 목적지를 오가는 운전하는 시간이 전혀 지겹지 않았을 정도다. 오후에 집으로 돌아와서 조금 쉬다가, 저녁이 돼서야 다시 본격적인 코딩을 시작했다.&lt;/p&gt;

&lt;h3 id=&#34;git-그래프-그리기:204468a805dd79c7901a2a61584e3071&#34;&gt;Git 그래프 그리기&lt;/h3&gt;

&lt;p&gt;하고자 하는 작업은 Git 저장소의 커밋 이력을 그래프로 보여주는 작업. 흔히 쓰는 GUI 툴에서 보여주는 것이나, 터미널에서 &lt;code&gt;git log --graph --oneline&lt;/code&gt;처럼 &lt;code&gt;--graph&lt;/code&gt; 옵션으로 보는 그래프 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hatemogi.com/img/post/holiday-project/git-graph-sourcetree.png&#34; class=&#34;img-rounded&#34; style=&#34;width: 400px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;위 이미지 중앙의 그래프 같은 것. 보통 저 그래프는 커밋과 브랜치의 흐름을 &lt;em&gt;부차적으로&lt;/em&gt; 확인하기에 좋은데, 저 정보를 &lt;strong&gt;중심으로 바라보는&lt;/strong&gt; 그래프를 그려보고 싶었다. 시간의 흐름 순으로 위에서 아래나, 왼쪽에서 오른쪽으로 표현하는 것이 가장 일반적인데, 조금 더 자유롭게 표현해보면 어떨까 하는 호기심이 일었고, 새벽에 보았던 D3.js의 &lt;a href=&#34;https://github.com/mbostock/d3/wiki/Force-Layout&#34;&gt;Force Layout&lt;/a&gt;를 써서 그려봤다.&lt;/p&gt;

&lt;p&gt;&lt;style&gt;
  circle {
    stroke: black;
    stroke-width: 1.5px;
    fill: steelblue;
    cursor: pointer;
  }
  line {
    stroke: darkgrey;
    stroke-width: 1.5px;
  }
  text {
    fill: white;
    text-anchor: middle;
    cursor: pointer;
  }
  path {
    stroke: darkgrey;
    stroke-width: 2px;
    fill: none;
  }
&lt;/style&gt;&lt;/p&gt;

&lt;section class=&#34;button-section&#34;&gt;
  &lt;button class=&#34;pure-button pure-button-primary pure-button-lg show-button&#34;&gt;어디 한번 봅시다!&lt;/button&gt;
  이 버튼을 누르면, 오늘 그린 그림이 보인다.
&lt;/section&gt;

&lt;div class=&#34;graph-section&#34; style=&#34;display: none;&#34;&gt;
  &lt;h3&gt;어떤 Git 저장소의 master 브랜치에 있는 커밋들&lt;/h3&gt;
  &lt;svg class=&#34;d3&#34;&gt;&lt;/svg&gt;
  &lt;p&gt;
    &lt;button class=&#34;btn btn-warning resume-button&#34;&gt;흔들어봅시다!&lt;/button&gt;
  &lt;/p&gt;
  &lt;div class=&#34;panel panel-info&#34;&gt;
    &lt;div class=&#34;panel-heading&#34;&gt;
      원을 클릭해 보세요.
    &lt;/div&gt;
    &lt;div class=&#34;panel-body&#34;&gt;
      커밋메시지가 보일 거에요.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/nodegit/nodegit&#34;&gt;https://github.com/nodegit/nodegit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;볼만한가? 버튼을 누르면 드러나는 그래프는 &lt;a href=&#34;https://github.com/nodegit/nodegit&#34;&gt;nodegit&lt;/a&gt; 저장소의 &lt;code&gt;master&lt;/code&gt; 브랜치의 모든 커밋 정보를 가져와서, JSON 파일로 만들어 둔 뒤, D3.js의 Force Layout을 이용해 그래프로 표현한 것이다. 각각의 원이 하나의 커밋을 표현한 것이며, 커밋에 반영된 코드 변화분이 크면 클수록 원의 지름도 크게 표현했다. 원을 드래그해서 조금 위치를 흔들어 볼 수도 있다.&lt;/p&gt;

&lt;p&gt;별도의 위치 지정이나 텐션 조절을 하지 않은 기본값이며, 제대로 그리려면, 몇 가지 튜닝도 하고 다른 브랜치와의 관계도 보여야 할 것이며, 모든 커밋이 아니라 보여줘서 의미 있는 최근의 커밋들만 보이게 한다거나 하는 일이 필요하다.&lt;/p&gt;

&lt;p&gt;아쉽게도 큰 기대에 비해서 실망스러웠다. 이건 그냥 잔뜩 엉켜있는 그래프잖아. 어쩌면, 단순히 D3.js에 대충 데이터 던져주고 멋지게 그려주기를 바랐는지도 모른다. 새벽과 오전 내내의 설렘이, 비눗방울 터지듯 훅 가버렸지만, 계속 개선해보면 좀 멋진 그래프를 그릴 수 있을 거라고 스스로 위안해 본다.&lt;/p&gt;

&lt;p&gt;참고로, 아래는 위의 커밋 정보들을 JSON으로 뽑아낸 커피스크립트 코드다.&lt;/p&gt;

&lt;h4 id=&#34;repo-dump-coffee-https-github-com-hatemogi-karma-practice-blob-day-11-lib-repo-dump-coffee:204468a805dd79c7901a2a61584e3071&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/karma-practice/blob/day-11/lib/repo_dump.coffee&#34;&gt;repo_dump.coffee&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;# ... 앞 코드 생략
commits = {}
branches = {}

async.waterfall [
  (cb) -&amp;gt;
    git.Repo.open &#39;git/nodegit.git&#39;, cb
  (repo, cb) -&amp;gt;
    repo.getMaster cb
  (branch) -&amp;gt;
    history = branch.history(git.RevWalk.Sort.Topological)
    branches[&amp;quot;master&amp;quot;] ||= []
    history.on &#39;commit&#39;, (commit) -&amp;gt;
      parents = _.map(commit.parents(), (c) -&amp;gt; c.sha().substr(0,8))
      key = commit.sha().substr(0, 8)
      c = {
        sha: commit.sha()
        message: commit.message()
        author: commit.author
        parents: parents
      }
      branches[&amp;quot;master&amp;quot;].push key
      commits[key] = c
    history.on &#39;end&#39;, (r) -&amp;gt;
      console.log JSON.stringify({commits: commits, branches: branches})
    history.start()
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-10&#34;&gt;어제 정리한 Async.js&lt;/a&gt;를 이용해 콜백 중첩을 간소화했는데도, 여전히 계속 반복해 겹치는 콜백 스타일 코딩이 아직 적응되지 않는다.&lt;/p&gt;

&lt;p&gt;이렇게 커밋간의 차이점(diff) 크기를 수치화하기 위한 데이터를 작성하다가, 콜백 스타일 코딩이 답답해서, 평소 익숙한 &lt;a href=&#34;https://github.com/hatemogi/karma-practice/blob/day-11/lib/repo_dump.rb&#34;&gt;루비 코드로도 재작성&lt;/a&gt;해봤는데, 일반적인 호출 스타일이 논리적 흐름에 자연스럽게 느껴졌다. 아니면, 단지 익숙하기 때문일 수도 있으니, 조금 더 써보며 적응해보려 한다.&lt;/p&gt;

&lt;p&gt;이상으로 D3.js를 조금 익혀서 Git 저장소의 커밋 정보를 그래프로 그려보았다. 비록 멋지게 그리는 데에는 실패했지만, 그래도 D3.js와는 조금 친해진 느낌이다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;

&lt;script&gt;
  var nodes = [];
  var links = [];

  var w = 700, h = 400;

  var chart = d3.select(&#34;svg.d3&#34;)
    .attr(&#34;width&#34;, w)
    .attr(&#34;height&#34;, h);

  var force = d3.layout.force()
    .distance(1)
    .nodes(nodes)
    .links(links)
    .size([w, h]);

  function circle_click() {
    data = d3.select(this.parentNode).datum();
    a = &#34;&lt;a href=&#39;https://github.com/nodegit/nodegit/commit/&#34; + data.sha + &#34;&#39;&gt; GitHub 링크: &#34; + data.sha.substr(0, 8) + &#34;&lt;/a&gt;&#34;;
    $(&#39;.panel-heading&#39;).html(a);
    $(&#39;.panel-body&#39;).text(data.message);
    console.log(data);
  }

  d3.json(&#39;/js/holiday-project/day-11.json&#39;, function(r, json) {
    json[&#39;branches&#39;].master.forEach(function(c, i) {
      nodes[i] = json.commits[c];
      nodes[i].index = i;
    });

    nodes.forEach(function(c, i) {
      c.parents.forEach(function(p) {
        links.push({source: c.index, target: json.commits[p].index});
      });
    });

    var link = chart.selectAll(&#34;line&#34;)
      .data(links)
      .enter().append(&#34;line&#34;);

    var node = chart.selectAll(&#34;g&#34;)
      .data(nodes)
      .enter().append(&#34;g&#34;)
      .attr(&#34;r&#34;, function(d) { return Math.min(d.change_level, 10); })
      .call(force.drag);

    node.append(&#34;circle&#34;)
      .attr(&#34;r&#34;, function(d) { return Math.min(d.change_level, 10); })
      .on(&#39;click&#39;, circle_click);

    // node.append(&#34;text&#34;).text(function(d) { return d.index; }).attr(&#34;dy&#34;, &#34;.35em&#34;);

    force.on(&#34;tick&#34;, function() {
      link.attr(&#34;x1&#34;, function(d) { return d.source.x; })
          .attr(&#34;y1&#34;, function(d) { return d.source.y; })
          .attr(&#34;x2&#34;, function(d) { return d.target.x; })
          .attr(&#34;y2&#34;, function(d) { return d.target.y; });
      node.attr(&#34;transform&#34;, function(d) { return &#34;translate(&#34; + d.x + &#34;,&#34; + d.y + &#34;)&#34;; });
    });
  });

  $(&#39;.show-button&#39;).on(&#39;click&#39;, function() {
    $(this.parentNode).hide();
    $(&#39;.graph-section&#39;).removeClass(&#39;hide&#39;).show(function() {
      force.start();
    });
  });

  $(&#39;.resume-button&#39;).on(&#39;click&#39;, function() {
    force.alpha(.99);
  });
&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>프로젝트 10일: Async.js로 콜백 중첩을 풀기</title>
      <link>http://hatemogi.com/holiday-project-day-10</link>
      <pubDate>Fri, 16 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hatemogi.com/holiday-project-day-10</guid>
      <description>

&lt;p&gt;나는 30일의 휴가 중이다. 휴가 동안 개인 개발 프로젝트를 진행하고 있고, 오늘은 그 열흘째다.&lt;/p&gt;

&lt;h2 id=&#34;async-js:fc889b51911c8dc001a83e3cda8bfe91&#34;&gt;&lt;a href=&#34;https://github.com/caolan/async&#34;&gt;Async.js&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-09/&#34;&gt;어제 Node.js로 Git 저장소의 커밋 오브젝트를 찾아보면서, 콜백 폭포에 대한 어색함을 토로했다.&lt;/a&gt; 출근하면, 회사 동료들에게 관련 내용을 물어보려 했는데, 오늘 마침 회사에 잠깐 들를 일이 있었다. 딸내미 100일 떡을 돌리라는 명(?)을 받들어 회사에 가서 막 쪄온 떡을  돌리고, 오랜만에 본 팀원 분들과 얘기를 나누며 관련 문의를 했고, 곧바로 속 시원하게 들은 해결안은 &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;Async.js&lt;/a&gt;를 사용해보라는 것!&lt;/p&gt;

&lt;p&gt;집에 와서 살펴보니, &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;Async.js&lt;/a&gt;는 여러 가지 비동기 호출에 편리한 기능을 제공하는데, 그중에서 &lt;a href=&#34;https://github.com/caolan/async#waterfall&#34;&gt;waterfall&lt;/a&gt; 함수를 사용하면 자꾸 중첩되는 콜백 함수들을 명시적으로 표현해 호출하기에 좋다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async.waterfall(tasks, [callback])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;waterfall 함수는 &lt;code&gt;tasks&lt;/code&gt; 배열과, 에러 &lt;code&gt;callback&lt;/code&gt;을 파라미터로 받는다. &lt;code&gt;tasks&lt;/code&gt; 배열에 넣어 전달하는 각각의 함수는 차례로 실행되며, 그 전에 실행된 함수에서 호출한 &lt;code&gt;callback&lt;/code&gt; 함수를 통해 다음 함수로 전달된다. 만약 실행된 함수에서 &lt;code&gt;callback&lt;/code&gt;의 첫 번째 파라미터인 &lt;code&gt;err&lt;/code&gt;에 &lt;code&gt;null&lt;/code&gt;이 아닌 값을 넣어 호출한다면 &amp;ndash; 즉 에러가 발생하면 &amp;ndash; 그 뒤의 함수들은 호출되지 않고, waterfall의 두 번째 파라미터였던 에러 &lt;code&gt;callback&lt;/code&gt;이 실행되면서 err 값이 전달된다.&lt;/p&gt;

&lt;p&gt;내용도 어렵고, 내 표현력도 부족해서 이해하기 쉽지 않다. 사이트의 예제를 그대로 가져와 다시 설명하자.&lt;/p&gt;

&lt;h3 id=&#34;waterfall-예제:fc889b51911c8dc001a83e3cda8bfe91&#34;&gt;&lt;a href=&#34;https://github.com/caolan/async#waterfall&#34;&gt;waterfall&lt;/a&gt; 예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async.waterfall([
  function(callback){
    callback(null, &#39;하나&#39;, &#39;둘&#39;);
  },
  function(arg1, arg2, callback){
    // arg1는 &#39;하나&#39;고, arg2는 &#39;둘&#39;이다.
    callback(null, &#39;셋&#39;);
  },
  function(arg1, callback){
    // arg1은 &#39;셋&#39;이다.
    callback(null, &#39;끝&#39;);
  }
], function (err, result) {
   // result에는 &#39;끝&#39;이 담겨 온다.
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예제에서 waterfall 함수의 첫 번째 파라미터 &lt;code&gt;tasks&lt;/code&gt;에 익명 함수 3개를 전달했고, 마지막 콜백 함수도 표현돼 있다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;첫 번째 익명 함수는 처음 실행되는 함수이기에, 별도 파라미터 없이, callback 함수만 파라미터로 받았고, 그 함수를 곧바로 실행했으며, 첫 번째 파라미터가 &lt;code&gt;null&lt;/code&gt;이므로, 문제없이 두 번째 익명 함수를 호출한다. 그리고, 그때 전달하는 인자는 &lt;code&gt;하나&lt;/code&gt;와 &lt;code&gt;둘&lt;/code&gt;이 된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;두 번째 익명 함수는, 첫째 함수에서 callback 함수를 호출하며 파라미터로 전달한 &lt;code&gt;하나&lt;/code&gt;와 &lt;code&gt;둘&lt;/code&gt;을 각각 arg1과 arg2로 받았고, 이 익명 함수에서는 호출하는 callback에는 &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;셋&lt;/code&gt;을 전달하므로, 정상적으로 세 번째 익명 함수를 호출한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;마지막으로, 세 번째 익명 함수는, &lt;code&gt;셋&lt;/code&gt;을 받은 뒤, 마지막 callback으로 &lt;code&gt;끝&lt;/code&gt;을 담아 호출한다. 그러면 최종적으로 waterfall의 두 번째 파라미터인 callback 함수에 err는 null, result에는 &lt;code&gt;끝&lt;/code&gt;을 담아 호출한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만약 여기서 두 번째 익명함수를 살짝 바꿔서 아래와 같이 호출한다면 어떻게 될까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 전략
  function(arg1, arg2, callback){
    // arg1는 &#39;하나&#39;고, arg2는 &#39;둘&#39;이다.
    callback(&amp;quot;어떤 에러&amp;quot;, &#39;셋&#39;);
  },
  // 후략
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이럴 경우, callback의 err 파라미터가 null이 아니므로, &lt;strong&gt;세 번째 익명 함수를 호출하지 않은채&lt;/strong&gt;, 마지막 콜백 함수가 호출되며, 해당 콜백에는 &lt;code&gt;어떤 에러&lt;/code&gt;와 &lt;code&gt;셋&lt;/code&gt;을 전달한다.&lt;/p&gt;

&lt;p&gt;조금 복잡하긴 하지만, node.js에서 흔히 쓰는 &amp;ldquo;중첩된 비동기 호출&amp;rdquo;을 깔끔히 처리하기 좋은 방법이다.&lt;/p&gt;

&lt;h2 id=&#34;어제의-콜백-폭포를-다시-쓴다면:fc889b51911c8dc001a83e3cda8bfe91&#34;&gt;어제의 콜백 폭포를 다시 쓴다면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hatemogi.com/holiday-project-day-09/&#34;&gt;어제&lt;/a&gt;의 코드를 다시 보자. &lt;a href=&#34;http://www.nodegit.org/&#34;&gt;nodegit&lt;/a&gt;을 이용해 Git 저장소를 열고, 특정 커밋 객체를 찾아보는 테스트 코드다. 이번에는 커피스크립트 코드로 살펴보자.&lt;/p&gt;

&lt;h3 id=&#34;repo-spec-coffee-https-github-com-hatemogi-karma-practice-blob-day-10-spec-nodegit-repo-spec-coffee:fc889b51911c8dc001a83e3cda8bfe91&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/karma-practice/blob/day-10/spec/nodegit/repo_spec.coffee&#34;&gt;repo_spec.coffee&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;어제의 원래 코드이고, 콜백이 여러번 중첩됐다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)

describe &#39;[CoffeeScript] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    nodegit.Repo.open &amp;quot;git/nodegit&amp;quot;, (err, repo) -&amp;gt;
      return done(err) if err
      expect(repo.path()).toMatch /\.git\/$/
      repo.getCommit sha, (err, entry) -&amp;gt;
        return done(err) if err
        expect(entry.sha()).toEqual sha
        done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원래 코드는 저장소를 open 함수로 열고, 에러 발생 여부를 확인하고, 커밋 객체를 찾아보고, 또 에러 발생 여부를 확인한 뒤, 마지막으로 jasmine 테스트 완료를 통보(callback)한다. 코드 중간마다 에러 발생 여부를 확인하는 코드와 더는 실행하지 않게 하는 &lt;code&gt;return&lt;/code&gt; 구문이 필요하다. (일반 코드라면 throw로 확실하게 중단 하는 것이 좋겠지만, jasmine에 에러 내역을 &lt;code&gt;done(err)&lt;/code&gt; 함수로 전달하기 위해 return으로 종료했다.)&lt;/p&gt;

&lt;h3 id=&#34;repo-async-spec-coffee-https-github-com-hatemogi-karma-practice-blob-day-10-spec-nodegit-repo-async-spec-coffee:fc889b51911c8dc001a83e3cda8bfe91&#34;&gt;&lt;a href=&#34;https://github.com/hatemogi/karma-practice/blob/day-10/spec/nodegit/repo_async_spec.coffee&#34;&gt;repo_async_spec.coffee&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;아래는, async.&lt;a href=&#34;https://github.com/caolan/async#waterfall&#34;&gt;waterfall&lt;/a&gt;로 다시 쓴 코드다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;nodegit = require(&amp;quot;nodegit&amp;quot;)
async = require(&amp;quot;async&amp;quot;)

describe &#39;[CoffeeScript w/async.js] nodegit 저장소&#39;, () -&amp;gt;
  it &#39;열어서 커밋 찾아보기&#39;, (done) -&amp;gt;
    sha = &amp;quot;e9ec116a8fb2ea051a4c2d46cba637b3fba30575&amp;quot;
    async.waterfall [
      (callback) -&amp;gt;
        nodegit.Repo.open &amp;quot;git/nodegit&amp;quot;, callback
      (repo, callback) -&amp;gt;
        expect(repo.path()).toMatch /\.git\/$/
        repo.getCommit sha, callback
      (entry, callback) -&amp;gt;
        expect(entry.sha()).toEqual sha
        callback null
    ], (err, _result) -&amp;gt; done(err)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;waterfall로 작성한 코드는 위와 같다. 콜백 &lt;strong&gt;폭포(중첩)&lt;/strong&gt;를, 익명 함수의 &lt;strong&gt;나열&lt;/strong&gt;로 간소화했으며, 중간마다 에러 발생 여부를 검사하는 코드도 보이지 않아서, 논리적 흐름을 거침없이 볼 수 있다. 공교롭게도(?) 코드 라인 수는 늘어났기에, 이 경우 확실히 waterfall을 사용한 것이 낫다고 주장하기 어려운 면도 있지만, 개인적으로는 전체 흐름을 한 눈에 파악하기 쉽기 때문에 종종 사용하게 될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caolan/async#waterfall&#34;&gt;waterfall&lt;/a&gt; 말고도, &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;Async.js&lt;/a&gt;에 비동기 함수 호출을 하는 데 편리한 함수들이 많아서, 틈틈히 참고해가며 코딩하기로 한다.&lt;/p&gt;

&lt;p&gt;오늘은 여기까지.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>